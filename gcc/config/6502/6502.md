; Register constraints (not finalised)
; A -- hard accumulator reg
; x -- hard X reg
; y -- hard Y reg
; h -- all hard regs
; r -- general regs
; S -- stack reg

(define_constants
  [(CC_REGNUM 36)])

; There isn't really a sane default length for an instruction. Pick 2 (bytes).
(define_attr "length" ""
  (const_int 2))

(include "constraints.md")
(include "predicates.md")

(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand"
	  "=Ah,xh,yh,Ah,Ah,xh,yh,Ah, r,xh, r,yh, r,Ah, m,xh, m,yh, m")
	(match_operand:QI 1 "general_operand"
	  "  I, I, I,xh,yh,Ah,Ah, r,Ah, r,xh, r,yh, m,Ah, m,xh, m,yh"))]
  ""
  "@
  lda #%1
  ldx #%1
  ldy #%1
  txa
  tya
  tax
  tay
  lda %1
  sta %0
  ldx %1
  stx %0
  ldy %1
  sty %0
  lda %1
  sta %0
  ldx %1
  stx %1
  ldy %1
  sty %1"
 [(set_attr "length" "2,2,2,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3")])

; There are some cases here that it might be profitable to add -- e.g.
; immediate to ZP register.

(define_insn "movhi"
  [(set (match_operand:HI 0 "movhi_dst_operand"	"=hc,Ac,jc,hc, ?r,hc,r,U,r,U")
	(match_operand:HI 1 "movhi_src_operand"	 "i, jc,Ac, r,?hc, U,r,r,U,U"))]
  ""
{
  switch (which_alternative)
    {
    case 0:  /* h := i.  */
      switch (REGNO (operands[0]))
        {
	case ACC_REGNUM: return "lda #>%1\;sta ah\;lda #<%1";
	case X_REGNUM: return "ldx #>%1\;stx xh\;ldx #<%1";
	case Y_REGNUM: return "ldy #>%1\;sty yh\;ldx #<%1";
	default: gcc_unreachable ();
	}
      break;
    
    case 1:  /* A := j.  */
      switch (REGNO (operands[1]))
        {
	case X_REGNUM: return "lda xh\;sta ah\;txa";
	case Y_REGNUM: return "lda yh\;sta ah\;tya";
	default: gcc_unreachable ();
	}
      break;
    
    case 2:  /* j := A.  */
      switch (REGNO (operands[0]))
        {
	case X_REGNUM: return "ldx ah\;stx xh\;tax";
	case Y_REGNUM: return "ldy ah\;sty yh\;tay";
	default: gcc_unreachable ();
	}
      break;
    
    case 3:  /* h := r.  */
      switch (REGNO (operands[0]))
        {
	case ACC_REGNUM: return "lda %h1\;sta ah\;lda %1";
	case X_REGNUM: return "ldx %h1\;stx xh\;ldx %1";
	case Y_REGNUM: return "ldy %h1\;sty yh\;ldy %1";
	default: gcc_unreachable ();
	}
      break;
    
    case 4:  /* r := h.  */
      /* We can't store HImode hard regs without clobbering them.  If
         the (or a) hard reg is dead after the insn, we can use a peephole2 to
	 avoid preserving it.  */
      switch (REGNO (operands[1]))
        {
	case ACC_REGNUM: return "pha\;lda ah\;sta %h0\;pla\;sta %0";
	case X_REGNUM: return "pha\;lda xh\;sta %h0\;pla\;stx %0";
	case Y_REGNUM: return "pha\;lda yh\;sta %h0\;pla\;sty %0";
	default: gcc_unreachable ();
	}

    case 5:  /* h := U.  */
      switch (REGNO (operands[0]))
        {
	case ACC_REGNUM: return "lda %1+1\;sta ah\;lda %1";
	case X_REGNUM: return "ldx %1+1\;stx xh\;ldx %1";
	case Y_REGNUM: return "ldy %1+1\;sty yh\;ldy %1";
	default: gcc_unreachable ();
	}

    /* The following three are all cleaned up with a peephole2 if the
       accumulator (or another hard reg) is dead afterwards.  */

    case 6:  /* r := r.  */
      return "pha\;lda %1\;sta %0\;lda %h1\;sta %h0\;pla";

    case 7:  /* U := r.  */
      return "pha\;lda %1\;sta %0\;lda %h1\;sta %0+1\;pla";

    case 8:  /* r := U.  */
      return "pha\;lda %1\;sta %0\;lda %1+1\;sta %h0\;pla";

    case 9:  /* U := U.  */
      return "pha\;lda %1\;sta %0\;lda %1+1\;sta %0+1\;pla";

    default:
      gcc_unreachable ();
    }
  
  return "";
}
  [(set_attr "length" "6,5,5,6,8,8,9,8,12,14")])

; This peephole improves hard-reg storing (to ZP regs) if the value held in the
; reg (or a different one in fact) is dead after the insn.

(define_peephole2
  [(set (match_operand:HI 0 "zp_reg_operand" "")
	(match_operand:HI 1 "hard_reg_operand" ""))
   (match_scratch:QI 2 "hh")]
  ""
  [(parallel [(set (match_dup 0) (match_dup 1))
	      (clobber (match_dup 2))])]
  "")

(define_insn "store_clobber_hardreg_to_zp"
  [(set (match_operand:HI 0 "zp_reg_operand"	"=r")
	(match_operand:HI 1 "hard_reg_operand"  "hc"))
   (clobber (match_scratch:QI 2 "=hh"))]
  ""
{
  switch (REGNO (operands[1]))
    {
    case ACC_REGNUM: return "sta %0\;ld%R2 ah\;st%R2 %h0";
    case X_REGNUM: return "stx %0\;ld%R2 xh\;st%R2 %h0";
    case Y_REGNUM: return "sty %0\;ld%R2 yh\;st%R2 %h0";
    default: gcc_unreachable ();
    }
}
  [(set_attr "length" "6")])

; This peephole helps with ZP register/register moves, loads and stores (to
; plain register-indirect memory locations).

(define_peephole2
  [(set (match_operand:HI 0 "zp_reg_or_const_mem_operand" "")
	(match_operand:HI 1 "zp_reg_or_const_mem_operand" ""))
   (match_scratch:QI 2 "hh")]
  ""
  [(parallel [(set (match_dup 0) (match_dup 1))
	      (clobber (match_dup 2))])]
  "")

; Move HImode zero-page registers or absolute memory values around, clobbering
; a hard register in the process.

(define_insn "zp_clob_hardreg_mov_load_store"
  [(set (match_operand:HI 0 "zp_reg_or_const_mem_operand" "=r,U,r,U")
	(match_operand:HI 1 "zp_reg_or_const_mem_operand"  "r,r,U,U"))
   (clobber (match_scratch:QI 2 "=hh,hh,hh,hh"))]
  ""
  "@
  ld%R2 %1\;st%R2 %0\;ld%R2 %h1\;st%R2 %h0
  ld%R2 %1\;st%R2 %0\;ld%R2 %h1\;st%R2 %0+1
  ld%R2 %1\;st%R2 %0\;ld%R2 %1+1\;st%R2 %h0
  ld%R2 %1\;st%R2 %0\;ld%R2 %1+1\;st%R2 %0+1"
  [(set_attr "length" "8,10,10,12")])

; Store Y to indirect-Y location.  This one must preserve hard registers.

(define_insn "movhi_sty_indy"
  [(set (mem:HI (plus:HI (match_operand:HI 0 "register_operand" "r")
			 (match_operand:HI 1 "immediate_operand" "I")))
	(match_operand:HI 2 "y_reg_operand" "yc"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[1]);
  
  operands[1] = GEN_INT (offset + 1);
  
  return "pha\;tya\;pha\;ldy #%1\;lda yh\;sta (%0),y\;pla\;dey\;"
	 "sta (%0),y\;tay\;pla";
}
  [(set_attr "length" "15")])

; Load Y from indirect-Y location.  This must preserve hard registers too.

(define_insn "movhi_ldy_indy"
  [(set (match_operand:HI 0 "y_reg_operand" "=yc")
	(mem:HI (plus:HI (match_operand:HI 1 "register_operand" "r")
			 (match_operand:HI 2 "immediate_operand" "I"))))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[2]);
  
  operands[2] = GEN_INT (offset + 1);
  
  return "pha\;ldy #%2\;lda (%1),y\;sta yh\;dey\;lda (%1),y\;tay\;pla";
}
  [(set_attr "length" "12")])

; Load HImode accumulator from indirect or indirect-Y address.

(define_expand "reload_inhi_acc_indy"
  [(parallel [(set (match_operand:HI 0 "accumulator_operand" "=Ac")
        	   (match_operand:HI 1 "memory_operand" "m"))
	      (clobber (match_operand:QI 2 "y_reg_operand" "=&yh"))])]
  ""
{
  if (REG_P (XEXP (operands[1], 0)))
    operands[1] = gen_rtx_MEM (HImode,
		    gen_rtx_PLUS (HImode, operands[1], const0_rtx));
})

(define_insn "load_acc_indy"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
        (mem:HI (plus:HI (match_operand:HI 1 "register_operand"   "r, r")
			 (match_operand:HI 2 "immediate_operand"  "z, I"))))
   (clobber (match_scratch:QI 3 "=&yh,&yh"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[2]);

  operands[2] = GEN_INT (offset + 1);

  switch (which_alternative)
    {
    case 0: return "ldy #1\;lda (%1),y\;sta ah\;lda (%1)";
    case 1: return "ldy #%2\;lda (%1),y\;sta ah\;dey\;lda (%1),y";
    default: gcc_unreachable ();
    }
}
  [(set_attr "length" "8,9")])

; Store HImode accumulator to indirect or indirect-Y address.

(define_expand "reload_outhi_acc_indy"
  [(parallel [(set (match_operand:HI 0 "memory_operand"      "=m")
		   (match_operand:HI 1 "accumulator_operand" "Ac"))
	      (clobber (match_operand:QI 2 "y_reg_operand" "=&yh"))])]
  ""
{
  if (REG_P (XEXP (operands[0], 0)))
    operands[0] = gen_rtx_MEM (HImode,
		    gen_rtx_PLUS (HImode, operands[0], const0_rtx));
})

(define_insn "store_acc_indy"
  [(set (mem:HI (plus:HI (match_operand:HI 0 "register_operand"  "r,r")
			 (match_operand:HI 1 "immediate_operand" "z,I")))
	(match_operand:HI 2 "accumulator_operand" "Ac,Ac"))
   (clobber (match_scratch:QI 3 "=&yh,&yh"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[1]);
  
  operands[1] = GEN_INT (offset);

  /* Tsk tsk, we can't clobber two different registers, but really we'd like to
     do so.  Preserve accumulator instead.  */
  switch (which_alternative) 
    {
    case 0: return "sta (%0)\;ldy #1\;pha\;lda ah\;sta (%0),y\;pla";
    case 1: return "ldy #%1\;sta (%0),y\;iny\;pha\;lda ah\;sta (%0),y\;pla";
    default: gcc_unreachable ();
    }
}
  [(set_attr "length" "10,11")])

; Store HImode hard register to absolute memory location.

(define_expand "reload_outhi_hardreg_abs"
  [(parallel [(set (match_operand:HI 0 "const_mem_operand" "=U")
		   (match_operand:HI 1 "hard_reg_operand"   "hc"))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=&hh"))])])

(define_insn "store_hard_reg_abs"
  [(set (match_operand:HI 0 "const_mem_operand" "=U")
	(match_operand:HI 1 "hard_reg_operand"  "hc"))
   (clobber (match_scratch:QI 2 "=&hh"))]
  ""
  "st%R1 %0\;ld%R2 %R1h\;st%R2 %0+1"
  [(set_attr "length" "8")])

; Move HImode absolute memory location to another HImode memory location.

(define_expand "reload_outhi_noreg_abs"
  [(parallel [(set (match_operand:HI 0 "const_mem_operand" "")
		   (match_operand:HI 1 "const_mem_operand" ""))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=&hh"))])])

(define_insn "movhi_abs_abs"
  [(set (match_operand:HI 0 "const_mem_operand" "=U")
	(match_operand:HI 1 "const_mem_operand"  "U"))
   (clobber (match_operand:QI 2 "hard_reg_operand" "=&hh"))]
  ""
  "ld%R2 %1\;st%R2 %0\;ld%R2 %1+1\;st%R2 %0+1"
  [(set_attr "length" "12")])

; HImode arithmetic.

(define_insn "addhi3"
  [(set (match_operand:HI 0 "zp_reg_or_acc_operand"
					       "=r, r,Ac,Ac,Ac,Ac,r,r,r,r")
	(plus:HI (match_operand:HI 1 "zp_reg_or_acc_operand"
					       "%r,Ac, 0, 0, 0, 0,r,0,0,r")
		 (match_operand:HI 2 "nonmemory_operand"
					       "Ac, i, r, K, I, i,r,K,I,i")))]
  ""
  "@
  pha\;clc\;adc %1\;sta %0\;lda ah\;adc %h1\;sta %h0\;pla
  pha\;clc\;adc #<%2\;sta %0\;lda ah\;adc #>%2\;sta %h0\;pla
  clc\;adc %2\;pha\;lda ah\;adc %h2\;sta ah\;pla
  inc a\;bne :+\;inc ah\;:
  clc\;adc #%2\;bcc :+\;inc ah\;:
  clc\;adc #<%2\;pha\;lda ah\;adc #>%2\;sta ah\;pla
  pha\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;pla
  inc %0\;bne :+\;inc %h0\;:
  pha\;lda %0\;clc\;adc #%2\;sta %0\;bcc :+\;inc %h0\;:\;pla
  pha\;lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0\;pla"
  [(set_attr "length" "13,13,11,5,7,11,15,6,13,15")])

; If destination is a ZP register, we might not need the value in the
; accumulator afterwards so we can get away with not saving it.

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_operand:HI 1 "zp_reg_or_acc_operand" "")
		 (match_operand:HI 2 "nonmemory_operand" "")))
   (match_scratch:QI 3 "Ah")]
  ""
  [(parallel [(set (match_dup 0) (plus:HI (match_dup 1) (match_dup 2)))
	      (clobber (match_dup 3))])]
  "")

; These adds clobber the accumulator.

(define_insn "addhi3_zp_clob_acc"
  [(set (match_operand:HI 0 "register_operand"		     "=r, r,r,r,r,r")
	(plus:HI (match_operand:HI 1 "zp_reg_or_acc_operand" "%r,Ac,r,0,0,r")
		 (match_operand:HI 2 "nonmemory_operand"     "Ac, i,r,K,I,i")))
   (clobber (match_scratch:QI 3 "=Ah,Ah,Ah,X,Ah,Ah"))]
  ""
  "@
  clc\;adc %1\;sta %0\;lda ah\;adc %h1\;sta %h0
  clc\;adc #<%2\;sta %0\;lda ah\;adc #>%2\;sta %h0
  lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0
  inc %0\;bne :+\;inc %h0\;:
  lda %0\;clc\;adc #%2\;sta %0\;bcc :+\;inc %h0\;:
  lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0"
  [(set_attr "length" "11,11,13,6,11,13")])

(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
	(lshiftrt:HI (match_operand:HI 1 "accumulator_operand"	  "0, 0")
		     (match_operand:HI 2 "shifthi_amount"	 "Nr,Nc")))
   (clobber (match_scratch:QI 3 "=&X,&jh"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "lsr ah\;ror a";
    case 2: return "lsr ah\;ror a\;lsr ah\;ror a";
    case 3: return "lsr ah\;ror a\;lsr ah\;ror a\;lsr ah\;ror a";
    case 4: return "lsr ah\;ror a\;lsr ah\;ror a\;lsr ah\;ror a\;lsr ah\;ror a";
    case 5:
      return "cmp #$80\;rol ah\;rol a\;rol ah\;rol a\;rol ah\;rol a\;"
	     "and #7\;ld%R3 ah\;sta ah\;t%R3a";
    case 6:
      return "cmp #$80\;rol ah\;rol a\;rol ah\;rol a\;"
	     "and #3\;ld%R3 ah\;sta ah\;t%R3a";
    case 7:
      return "asl a\;rol ah\;lda ah\;stz ah\;rol ah";
    case 8: return "lda ah\;stz ah";
    case 9: return "lda ah\;ror a\;stz ah";
    case 10: return "lda ah\;ror a\;ror a\;stz ah";
    case 11: return "lda ah\;ror a\;ror a\;ror a\;stz ah";
    case 12: return "lda ah\;ror a\;ror a\;ror a\;ror a\;stz ah";
    case 13:
      return "lda #0\;asl ah\;rol a\;asl ah\;rol a\;asl ah\;rol a\;stz ah";
    case 14: return "lda #0\;asl ah\;rol a\;asl ah\;rol a\;stz ah";
    case 15: return "lda #0\;asl ah\;rol a\;stz ah";
    case 16: return "lda #0\;sta ah";
    default: gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
	       (eq (match_dup 2) (const_int 2)) (const_int 6)
	       (eq (match_dup 2) (const_int 3)) (const_int 9)
	       (eq (match_dup 2) (const_int 4)) (const_int 12)
	       (eq (match_dup 2) (const_int 5)) (const_int 18)
	       (eq (match_dup 2) (const_int 6)) (const_int 15)
	       (eq (match_dup 2) (const_int 7)) (const_int 9)
	       (eq (match_dup 2) (const_int 8)) (const_int 4)
	       (eq (match_dup 2) (const_int 9)) (const_int 5)
	       (eq (match_dup 2) (const_int 10)) (const_int 6)
	       (eq (match_dup 2) (const_int 11)) (const_int 7)
	       (eq (match_dup 2) (const_int 12)) (const_int 8)
	       (eq (match_dup 2) (const_int 13)) (const_int 13)
	       (eq (match_dup 2) (const_int 14)) (const_int 10)
	       (eq (match_dup 2) (const_int 15)) (const_int 7)
	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
	      (const_int 0)))])

; This can support more addressing modes!

(define_insn "lshrhi3_addhi"
  [(set (match_operand:HI 0 "zp_reg_operand"				"=r")
	(plus:HI (lshiftrt:HI (match_operand:HI 1 "accumulator_operand"  "Ac")
			      (match_operand:HI 2 "shifthi_rt_byteswap"  "Nc"))
		 (match_operand:HI 3 "zp_reg_operand"			 "r")))
   (clobber (match_scratch:QI 4 "=Ah"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 5:
      return "asl ah\;rol a\;asl ah\;rol a\;asl ah\;rol a\;and #7\;"
	     "pha\;lda %3\;clc\;adc ah\;sta %0\;pla\;adc %h3\;sta %h0";
    case 6:
      return "asl a\;rol ah\;php\;asl a\;rol ah\;pla\;asl a\;adc #0\;and #3\;"
	     "pha\;lda %3\;clc\;adc ah\;sta %0\;pla\;adc %h3\;sta %h0";
    default:
      gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 5)) (const_int 24)
	       (eq (match_dup 2) (const_int 6)) (const_int 26)]
	      (const_int 0)))])

(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
	(ashift:HI (match_operand:HI 1 "accumulator_operand"	 "0, 0")
		   (match_operand:HI 2 "shifthi_amount"		 "Nl,Nx")))
   (clobber (match_scratch:QI 3 "=&X,&jh"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "asl a\;rol ah";
    case 2: return "asl a\;rol ah\;asl a\;rol ah";
    case 3: return "asl a\;rol ah\;asl a\;rol ah\;asl a\;rol ah";
    case 4: return "asl a\;rol ah\;asl a\;rol ah\;asl a\;rol ah\;asl a\;rol ah";
    case 5:
      return "asl a\;rol ah\;asl a\;rol ah\;asl a\;rol ah\;asl a\;rol ah\;"
	     "asl a\;rol ah";
    case 6:
      return "tax\;lda ah\;ror a\;txa\;ror a\;ror ah\;ror a\;ror ah\;tax\;"
	     "lda ah\;and #$c0\;stx ah";
    case 7: return "lsr ah\;ror a\;sta ah\;lda #0\;ror a";
    case 8: return "sta ah\;lda #0";
    case 9: return "asl a\;sta ah\;lda #0";
    case 10: return "asl a\;asl a\;sta ah\;lda #0";
    case 11: return "asl a\;asl a\;asl a\;sta ah\;lda #0";
    case 12: return "asl a\;asl a\;asl a\;asl a\;sta ah\;lda #0";
    case 13: return "lsr a\;ror a\;ror a\;ror a\;and #$e0\;sta ah\;lda #0";
    case 14: return "lsr a\;ror a\;ror a\;and #$c0\;sta ah\;lda #0";
    case 15: return "lsr a\;lda #0\;sta ah\;ror ah";
    case 16: return "lda #0\;sta ah";
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
	       (eq (match_dup 2) (const_int 2)) (const_int 6)
	       (eq (match_dup 2) (const_int 3)) (const_int 9)
	       (eq (match_dup 2) (const_int 4)) (const_int 12)
	       (eq (match_dup 2) (const_int 5)) (const_int 15)
	       (eq (match_dup 2) (const_int 6)) (const_int 18)
	       (eq (match_dup 2) (const_int 7)) (const_int 8)
	       (eq (match_dup 2) (const_int 8)) (const_int 4)
	       (eq (match_dup 2) (const_int 9)) (const_int 5)
	       (eq (match_dup 2) (const_int 10)) (const_int 6)
	       (eq (match_dup 2) (const_int 11)) (const_int 7)
	       (eq (match_dup 2) (const_int 12)) (const_int 8)
	       (eq (match_dup 2) (const_int 13)) (const_int 10)
	       (eq (match_dup 2) (const_int 14)) (const_int 9)
	       (eq (match_dup 2) (const_int 15)) (const_int 7)
	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
	      (const_int 0)))])

(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
	(ashiftrt:HI (match_operand:HI 1 "accumulator_operand"   "0, 0")
		     (match_operand:HI 2 "shifthi_amount"	 "Na,Nb")))
   (clobber (match_scratch:QI 3 "=&jh,X"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "ld%R3 ah\;cp%R3 #$80\;ror ah\;ror a";
    case 2:
      return "ld%R3 ah\;cp%R3 #$80\;ror ah\;ror a\;cp%R3 #$80\;ror ah\;ror a";
    case 3:
      return "ld%R3 ah\;cp%R3 #$80\;ror ah\;ror a\;cp%R3 #$80\;ror ah\;ror a\;"
	     "cp%R3 #$80\;ror ah\;ror a";
    case 4:
      return "ld%R3 ah\;cp%R3 #$80\;ror ah\;ror a\;cp%R3 #$80\;ror ah\;ror a\;"
	     "cp%R3 #$80\;ror ah\;ror a\;cp%R3 #$80\;ror ah\;ror a";
    case 5:
      return "cmp #$80\;rol ah\;rol a\;rol ah\;rol a\;rol ah\;rol a\;"
	     "and #7\;ld%R3 ah\;sta ah\;and #4\;beq :+\;lda ah\;ora #$f8\;"
	     "sta ah\;:\;t%R3a";
    case 6:
      return "cmp #$80\;rol ah\;rol a\;rol ah\;rol a\;and #3\;ld%R3 ah\;"
	     "sta ah\;and #2\;beq :+\;lda ah\;ora #$fc\;sta ah\;:\;t%R3a";
    case 7:
      return "cmp #$80\;rol ah\;lda #0\;sbc #0\;eor #$ff\;ld%R3 ah\;sta ah\;"
	     "t%R3a";
    case 8:
      return "lda ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta ah\;t%R3a";
    case 9:
      return "lda ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta ah\;t%R3a\;"
	     "cmp #$80\;ror a";
    case 10:
      return "lda ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta ah\;t%R3a\;"
	     "cmp #$80\;ror a\;cmp #$80\;ror a";
    case 11:
      return "lda ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta ah\;t%R3a\;"
	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
    case 12:
      return "lda ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta ah\;t%R3a\;"
	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;"
	     "ror a";
    case 13:
      return "asl ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
	     "asl ah\;rol a\;asl ah\;rol a\;st%R3 ah";
    case 14:
      return "asl ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
	     "asl ah\;rol a\;st%R3 ah";
    case 15:
    case 16:
      return "asl ah\;lda #0\;sbc #0\;eor #$ff\;sta ah";
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 7)
	       (eq (match_dup 2) (const_int 2)) (const_int 12)
	       (eq (match_dup 2) (const_int 3)) (const_int 17)
	       (eq (match_dup 2) (const_int 4)) (const_int 22)
	       (eq (match_dup 2) (const_int 5)) (const_int 28)
	       (eq (match_dup 2) (const_int 6)) (const_int 25)
	       (eq (match_dup 2) (const_int 7)) (const_int 15)
	       (eq (match_dup 2) (const_int 8)) (const_int 12)
	       (eq (match_dup 2) (const_int 9)) (const_int 15)
	       (eq (match_dup 2) (const_int 10)) (const_int 18)
	       (eq (match_dup 2) (const_int 11)) (const_int 21)
	       (eq (match_dup 2) (const_int 12)) (const_int 24)
	       (eq (match_dup 2) (const_int 13)) (const_int 20)
	       (eq (match_dup 2) (const_int 14)) (const_int 17)
	       (eq (match_dup 2) (const_int 15)) (const_int 10)
	       (eq (match_dup 2) (const_int 16)) (const_int 10)]
	      (const_int 0)))])

(define_expand "cbranchhi4"
  [(parallel
    [(set (pc) (if_then_else
		 (match_operator 0 "himode_comparison"
	           [(match_operand:HI 1 "hard_reg_operand" "")
		    (match_operand:HI 2 "movhi_src_operand" "")])
		 (label_ref (match_operand 3 "" ""))
		 (pc)))
     (clobber (match_scratch:QI 4 ""))])]
  ""
{
})

(define_insn_and_split "cbrhi_eq"
  [(set (pc) (if_then_else
	       (eq (match_operand:HI 0 "register_operand" "hc,hc,hc,r,r")
		   (match_operand:HI 1 "movhi_src_operand" "r, i, U,r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hh,hh,hh,hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx op0_lo = gen_lowpart (QImode, operands[0]);
  rtx op1_lo = gen_lowpart (QImode, operands[1]);
  rtx op0_hi = gen_highpart (QImode, operands[0]);
  rtx op1_hi = gen_highpart (QImode, operands[1]);
  rtx new_label = gen_label_rtx ();
  rtx cmp, jmp_insn, i;
  rtx cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);
  int rev_prob = REG_BR_PROB_BASE - split_branch_probability;
  
  if (IS_ZP_REGNUM (REGNO (operands[0])))
    {
      emit_insn (gen_rtx_SET (VOIDmode, operands[3], op0_lo));
      op0_lo = operands[3];
    }
  
  emit_insn (gen_compareqi (op0_lo, op1_lo));
  cmp = gen_rtx_NE (VOIDmode, cc_reg, const0_rtx);
  jmp_insn = gen_condbranchqi (cmp, new_label);
  i = emit_jump_insn (jmp_insn);
  add_reg_note (i, REG_BR_PROB, GEN_INT (rev_prob));
  emit_insn (gen_rtx_SET (VOIDmode, operands[3], op0_hi));
  emit_insn (gen_compareqi (operands[3], op1_hi));
  cmp = gen_rtx_EQ (VOIDmode, cc_reg, const0_rtx);
  jmp_insn = gen_condbranchqi (cmp, operands[2]);
  i = emit_jump_insn (jmp_insn);
  add_reg_note (i, REG_BR_PROB, GEN_INT (split_branch_probability));
  emit_label (new_label);

  DONE;
})

(define_insn "cbrhi_ne"
  [(set (pc) (if_then_else
	       (ne (match_operand:HI 0 "register_operand"  "hc,hc,hc,r,r")
		   (match_operand:HI 1 "movhi_src_operand"  "r, i, U,r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hh,hh,hh,hh,hh"))]
  ""
{
  switch (which_alternative)
    {
    case 0:
      return "%C0 %1\;bne %2\;ld%R3 %R0h\;%C3 %h1\;bne %2";
    case 1:
      return "%C0 #<%1\;bne %2\;ld%R3 %R0h\;%C3 #>%1\;bne %2";
    case 2:
      return "%C0 %1\;bne %2\;ld%R3 %R0h\;%C3 %1+1\;bne %2";
    case 3:
      return "ld%R3 %0\;%C3 %1\;bne %2\;ld%R3 %h0\;%C3 %h1\;bne %2";
    case 4:
      return "ld%R3 %0\;%C0 #<%1\;bne %2\;ld%R3 %h0\;%C3 #>%1\;bne %2";
    default:
      gcc_unreachable ();
    }
}
  [(set_attr "length" "333")])

; QImode arithmetic.

(define_insn "addqi3"
  [(set (match_operand:QI 0 "register_operand"
					     "=Ah,Ah,Ah,Ah,xh,yh,Ah,xh,yh")
	(plus:QI (match_operand:QI 1 "register_operand"
					      "%0, 0, 0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
					       "r, m, K, I, K, K, M, L, L")))]
  ""
  "clc\;adc %2
   clc\;adc %2
   inc a
   clc\;adc #%2
   inx
   iny
   sec\;sbc #%2
   dex
   dey"
  [(set_attr "length" "3,3,1,3,1,1,3,1,1")])

(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand"		 "=Ah,Ah")
	(minus:QI (match_operand:QI 1 "register_operand"   "0, 0")
		  (match_operand:QI 2 "memory_operand"	   "r, m")))]
  ""
  "sec\;sbc %2
   sec\;sbc %2"
  [(set_attr "length" "3")])

(define_insn "andqi3"
  [(set (match_operand:QI 0 "register_operand"		"=Ah,Ah,Ah")
	(and:QI (match_operand:QI 1 "register_operand"	  "0, 0, 0")
		(match_operand:QI 2 "memory_operand"	  "r, m, I")))]
  ""
  "and %2
   and %2
   and #%2"
  [(set_attr "length" "2")])

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "register_operand"		"=Ah,Ah,Ah")
	(ior:QI (match_operand:QI 1 "register_operand"	  "0, 0, 0")
		(match_operand:QI 2 "memory_operand"	  "r, m, I")))]
  ""
  "ora %2
   ora %2
   ora #%2"
  [(set_attr "length" "2")])

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand"		"=Ah,Ah,Ah")
	(xor:QI (match_operand:QI 1 "register_operand"	  "0, 0, 0")
		(match_operand:QI 2 "memory_operand"	  "r, m, I")))]
  ""
  "eor %2
   eor %2
   eor #%2"
  [(set_attr "length" "2")])

(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand"		  "=Ah")
	(ashift:QI (match_operand:QI 1 "register_operand"   "0")
		   (const_int 1)))]
  ""
  "asl"
  [(set_attr "length" "1")])

(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand"		    "=Ah")
	(ashiftrt:QI (match_operand:QI 1 "register_operand"   "0")
		     (const_int 1)))]
  ""
  "lsr"
  [(set_attr "length" "1")])

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "register_operand"		  "=Ah")
	(match_operand:QI 1 "register_operand"		    "0"))]
  ""
  "eor #$ff"
  [(set_attr "length" "2")])

; Comparisons.

(define_insn "compareqi"
  [(set (reg:CC CC_REGNUM)
	(compare:CC (match_operand:QI 0 "hard_reg_operand"   "hh,hh,hh")
		    (match_operand:QI 1 "qimode_src_operand"  "r, I, U")))]
  "reload_completed"
  "@
  %C0 %1
  %C0 #%1
  %C0 %1"
  [(set_attr "length" "2,2,3")])

; Jumps & calls.

(define_insn "condbranchqi"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_comparison"
			[(reg:CC CC_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  "reload_completed"
  "%B0 %1"
  [(set_attr "length" "2")])

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "zp_reg_operand" "Ac,r"))]
  ""
  "@
  pha\;lda ah\;pha\;php\;rti
  jmp (%0)"
  [(set_attr "length" "6,2")])

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0"
  [(set_attr "length" "3")])

(define_insn "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "comparison_operator"
		 [(match_operand:QI 1 "register_operand"	"")
		  (match_operand:QI 2 "immediate_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  "1"
  "cmp foo\;bxx %3"
  [(set_attr "length" "4")])

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use (match_operand 2 "" ""))])])

(define_insn "call_sym"
  [(call (mem:QI (match_operand:HI 0 "" ""))
  	 (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))]
  "GET_CODE (operands[0]) == SYMBOL_REF"
  "jsr %0"
  [(set_attr "length" "3")])

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
        	   (call (match_operand 1 "memory_operand" "")
  			 (match_operand 2 "general_operand" "")))
	      (use (match_operand 3 "" ""))])])

(define_insn "call_value_sym"
  [(set (match_operand 0 "" "")
        (call (mem:QI (match_operand:HI 1 "" ""))
  	      (match_operand 2 "general_operand" "")))
   (use (match_operand 3 "" ""))]
  "GET_CODE (operands[1]) == SYMBOL_REF"
  "jsr %1"
  [(set_attr "length" "3")])

(define_insn "return"
  [(return)]
  ""
  "rts"
  [(set_attr "length" "1")])
