; Register constraints (not finalised)
; A -- hard accumulator reg
; x -- hard X reg
; y -- hard Y reg
; d -- index regs
; r -- general regs
; S -- stack reg

(include "constraints.md")

(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand"
	  "=A,x,y,A,A,x,y,A,r,x,r,y,r,A,m,x,m,y,m")
	(match_operand:QI 1 "general_operand"
	  " I,I,I,x,y,A,A,r,A,r,x,r,y,m,A,m,x,m,y"))]
  ""
  "@
  lda #%1
  ldx #%1
  ldy #%1
  txa
  tya
  tax
  tay
  lda %1
  sta %0
  ldx %1
  stx %0
  ldy %1
  sty %0
  lda %1
  sta %0
  ldx %1
  stx %1
  ldy %1
  sty %1")

(define_insn "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand"
	  "=A,x,y,A,A,x,y,A,r, x,Ur, y, r,r")
	(match_operand:HI 1 "general_operand"
	   "J,J,J,x,y,A,A,r,A,Ur, x,Ur,Uy,r"))]
  ""
  "@
  lda #>%1\;sta ah\;lda #<%1
  ldx #>%1\;stx xh\;ldx #<%1
  ldy #>%1\;sty yh\;ldx #<%1
  lda xh\;sta ah\;txa
  lda yh\;sta ah\;tya
  ldx ah\;stx xh\;tax
  ldy ah\;sty yh\;tay
  lda %1+1\;sta ah\;lda %1
  sta %0\;pha\;lda ah\;sta %0+1\;pla
  ldx %1+1\;sta xh\;ldx %1
  stx %0\;phx\;ldx xh\;stx %0+1\;plx
  ldy %1+1\;sta yh\;ldy %1
  sty %0\;phy\;ldy yh\;sty %0+1\;ply
  pha\;lda %1\;sta %0\;lda %1+1\;sta %0+1\;pla")

(define_insn "addqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A,A,x,y,A,x,y")
	(plus:QI (match_operand:QI 1 "register_operand"	"%0,0,0,0,0,0,0,0,0")
		 (match_operand:QI 2 "general_operand"	" r,m,K,I,K,K,M,L,L")))]
  ""
  "clc\;adc %2
   clc\;adc %2
   inc a
   clc\;adc #%2
   inx
   iny
   sec\;sbc #%2
   dex
   dey")

(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand"		 "=A,A")
	(minus:QI (match_operand:QI 1 "register_operand" " 0,0")
		  (match_operand:QI 2 "memory_operand"	 " r,m")))]
  ""
  "sec\;sbc %2
   sec\;sbc %2")

(define_insn "andqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A")
	(and:QI (match_operand:QI 1 "register_operand"	" 0,0,0")
		(match_operand:QI 2 "memory_operand"	" r,m,I")))]
  ""
  "and %2
   and %2
   and #%2")

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A")
	(ior:QI (match_operand:QI 1 "register_operand"	" 0,0,0")
		(match_operand:QI 2 "memory_operand"	" r,m,I")))]
  ""
  "ora %2
   ora %2
   ora #%2")

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A")
	(xor:QI (match_operand:QI 1 "register_operand"	" 0,0,0")
		(match_operand:QI 2 "memory_operand"	" r,m,I")))]
  ""
  "eor %2
   eor %2
   eor #%2")

(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand"		  "=A")
	(ashift:QI (match_operand:QI 1 "register_operand" " 0")
		   (const_int 1)))]
  ""
  "asl")

(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand"		    "=A")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" " 0")
		     (const_int 1)))]
  ""
  "lsr")

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "register_operand"		  "=A")
	(match_operand:QI 1 "register_operand"		  " 0"))]
  ""
  "eor #$ff")

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "general_operand" "A,r"))]
  ""
  "@
  pha\;lda AH\;pha\;php\;rti
  jmp (%0)")

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0")

(define_insn "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "comparison_operator"
		 [(match_operand:QI 1 "register_operand"	"")
		  (match_operand:QI 2 "immediate_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  "1"
  "cmp foo\;bxx %3")

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

(define_insn "call"
  [(call (match_operand 0 "memory_operand" "")
  	 (match_operand 1 "general_operand" ""))]
  ""
  "jsr %0")

(define_insn "call_value"
  [(set (match_operand 0 "register_operand" "")
        (call (match_operand 1 "memory_operand" "")
  	      (match_operand 2 "general_operand" "")))]
  ""
  "jsr %1")

(define_insn "return"
  [(return)]
  ""
  "rts")
