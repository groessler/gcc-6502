; Register constraints (not finalised)
; A -- hard accumulator reg
; x -- hard X reg
; y -- hard Y reg
; h -- all hard regs
; r -- general regs
; S -- stack reg

(define_constants
  [(ACC_REGNUM 0)
   (X_REGNUM 4)
   (Y_REGNUM 8)
   (CC_REGNUM 36)
   (HARDSP_REGNUM 40)])

(define_c_enum "unspec" [
  UNSPEC_SBC_OVF	; Overflow flag as set from SBC instruction.
  UNSPEC_NEG_HIBIT	; An eor #$80 setting overflow/negative bits.
  UNSPEC_LOADHI_CONSTMEM
  UNSPEC_LOADHI_IMMED
  UNSPEC_LOADHI_IMMED_PR
])

; There isn't really a sane default length for an instruction. Pick 2 (bytes).
(define_attr "length" ""
  (const_int 2))

(include "constraints.md")
(include "predicates.md")

;; HImode operations.

(define_insn "add_high"
  [(set (match_operand:HI 0 "zp_reg_operand" "=r")
	(plus:HI (high:HI (match_operand:HI 2 "y_reg_operand" "yc"))
		 (match_operand:HI 1 "zp_reg_operand" "0")))
   (clobber (match_scratch:QI 3 "=Ah"))]
  ""
  "lda %h1\;clc\;adc _yh\;sta %h0"
  [(set_attr "length" "7")])

(define_insn "lo_sum"
  [(set (match_operand:HI 0 "zp_reg_operand" "=r")
	(lo_sum:HI (match_operand:HI 1 "zp_reg_operand" "0")
		   (match_operand:HI 2 "y_reg_operand" "yc")))]
  ""
  "pha\;tya\;clc\;adc %1\;sta %0\;bcc :+\;inc %h0\;:\;pla"
  [(set_attr "length" "12")])

(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
{
  if (can_create_pseudo_p ())
    {
      if (memory_operand (operands[0], HImode)
	  && (memory_operand (operands[1], HImode)
	      || (GET_CODE (operands[1]) == CONST_INT
		  && INTVAL (operands[1]) != 0)
	      || (!CONSTANT_ADDRESS_P (XEXP (operands[0], 0))
		  && REG_P (operands[1])
		  && REGNO (operands[1]) != ACC_REGNUM)))
	operands[1] = copy_to_mode_reg (HImode, operands[1]);

      if (MEM_P (operands[0]))
        {
	  if (m65x_indirect_indexed_addr_p (HImode, XEXP (operands[0], 0),
					    false))
	    {
	      rtx mem_lo = adjust_address (operands[0], QImode, 0);
	      rtx plus = XEXP (operands[0], 0);
	      HOST_WIDE_INT hi_off = INTVAL (XEXP (plus, 1)) + 1;
	      rtx yreg = gen_reg_rtx (QImode);

	      emit_insn (gen_storehi_lowpart (XEXP (plus, 0), XEXP (plus, 1),
					      operands[1], yreg));
	      emit_insn (gen_storehi_highpart (XEXP (plus, 0), GEN_INT (hi_off),
					       operands[1], yreg));
	      DONE;
	    }
	  else if (zp_reg_operand (XEXP (operands[0], 0), HImode))
	    {
	      rtx mem_qimode = adjust_address (operands[0], QImode, 0);
	      rtx yreg = gen_reg_rtx (QImode);
	      
	      if (REG_P (XEXP (mem_qimode, 0)))
	        {
		  emit_insn (gen_storehi_lowpart (XEXP (mem_qimode, 0),
						  GEN_INT (0), operands[1],
						  yreg));
		  emit_insn (gen_storehi_highpart (XEXP (mem_qimode, 0),
						   GEN_INT (1), operands[1],
						   yreg));
		  DONE;
		}
	    }
	  else if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))
	    {
	      emit_insn (gen_storehi_constmem (operands[0], operands[1]));
	      DONE;
	    }
	  else
	    {
	      fprintf (stderr, "dst mem:\n");
	      debug_rtx (operands[0]);
	      gcc_unreachable ();
	    }
	}
      else if (MEM_P (operands[1]))
        {
	  if (m65x_indirect_indexed_addr_p (HImode, XEXP (operands[1], 0),
					    false))
	    {
	      rtx mem_lo = adjust_address (operands[1], QImode, 0);
	      rtx plus = XEXP (operands[1], 0);
	      HOST_WIDE_INT hi_off = INTVAL (XEXP (plus, 1)) + 1;
	      rtx yreg = gen_reg_rtx (QImode);

	      emit_insn (gen_loadhi_highpart (operands[0], XEXP (plus, 0),
					      GEN_INT (hi_off), yreg));
	      emit_insn (gen_loadhi_lowpart (operands[0], XEXP (plus, 0),
					     XEXP (plus, 1), operands[0],
					     yreg));
	      DONE;
	    }
	  else if (zp_reg_operand (XEXP (operands[1], 0), HImode))
	    {
	      rtx mem_qimode = adjust_address (operands[1], QImode, 0);
	      rtx yreg = gen_reg_rtx (QImode);
	      
	      if (REG_P (XEXP (mem_qimode, 0)))
	        {
		  emit_insn (gen_loadhi_highpart (operands[0],
						  XEXP (mem_qimode, 0),
						  GEN_INT (1), yreg));
		  emit_insn (gen_loadhi_lowpart (operands[0],
						 XEXP (mem_qimode, 0),
						 GEN_INT (0), operands[0],
						 yreg));
		  DONE;
		}
	    }
	  else if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))
	    {
	      emit_insn (gen_loadhi_constmem (operands[0], operands[1]));
	      DONE;
	    }
	  else
	    {
	      fprintf (stderr, "src mem:\n");
	      debug_rtx (operands[1]);
	      gcc_unreachable ();
	    }
	}
      else if (!lra_in_progress && register_operand (operands[0], HImode)
	       && register_operand (operands[1], HImode))
        {
	  /* Note: don't do this when LRA is in progress, because then the
	     scratch register can end up not allocated to anything (possibly a
	     middle-end bug, or possibly not).  In that case we'll have to fall
	     back to the post-reload movhi_insn splitter.  */
	  emit_insn (gen_movhi_reg (operands[0], operands[1]));
	  DONE;
	}
      else if (immediate_operand (operands[1], HImode))
        {
	  emit_insn (gen_loadhi_immed (operands[0], operands[1]));
	  DONE;
	}
      else if ((!REG_P (operands[0]) || HARD_REGISTER_P (operands[0]))
	       && (!REG_P (operands[1]) || HARD_REGISTER_P (operands[1])))
	{
	  rtx op0_lo = gen_lowpart (QImode, operands[0]);
	  rtx op1_lo = gen_lowpart (QImode, operands[1]);
	  rtx op0_hi = gen_highpart_mode (QImode, HImode, operands[0]);
	  rtx op1_hi = gen_highpart_mode (QImode, HImode, operands[1]);

	  emit_move_insn (op0_lo, op1_lo);
	  emit_move_insn (op0_hi, op1_hi);

	  DONE;
	}
    }
})

(define_insn_and_split "*movhi_insn"
  [(set (match_operand:HI 0 "mov_dst_operand"
			   "=hc,Ac,jc,Ac,xc,yc,hc, ?r,hc, U,Ac, m,r,r,r,U,U")
	(match_operand:HI 1 "mov_src_operand"
			     "i,jc,Ac,Ac,xc,yc, r,?hc, U,hc, m,Ac,r,i,U,r,z"))]
  "m65x_valid_mov_operands (HImode, operands)"
  "#"
  "&& reload_completed"
  [(pc)]
{
  if (MEM_P (operands[0])
      && (REG_P (XEXP (operands[0], 0))
	  || m65x_indirect_indexed_addr_p (HImode, XEXP (operands[0], 0),
					   true)))
    {
      gcc_unreachable ();
      /*emit_insn (gen_storehi_indirect_indexed (operands[0], operands[1]));
      DONE;*/
    }
  else if (MEM_P (operands[1])
	   && (REG_P (XEXP (operands[1], 0))
	       || m65x_indirect_indexed_addr_p (HImode, XEXP (operands[1], 0),
						true)))
    {
      gcc_unreachable ();
      /*emit_insn (gen_loadhi_indirect_indexed (operands[0], operands[1]));
      DONE;*/
    }
  else if (immediate_operand (operands[1], HImode))
    {
      emit_insn (gen_loadhi_immed_postreload (operands[0], operands[1]));
      DONE;
    }
  else
    {
      rtx op0_lo = gen_lowpart (QImode, operands[0]);
      rtx op1_lo = gen_lowpart (QImode, operands[1]);
      rtx op0_hi = gen_highpart_mode (QImode, HImode, operands[0]);
      rtx op1_hi = gen_highpart_mode (QImode, HImode, operands[1]);

      if (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)
	{
	  emit_move_insn (op0_lo, op1_lo);
	  emit_move_insn (op0_hi, op1_hi);
	}
      else if (REG_P (op0_lo) && IS_HARD_REGNUM (REGNO (op0_lo)))
	{
	  emit_move_insn (op0_lo, op1_hi);
	  emit_move_insn (op0_hi, op0_lo);
	  emit_move_insn (op0_lo, op1_lo);
	}
      else
	{
	  gcc_assert (!reg_overlap_mentioned_p (op0_lo, op1_hi));
	  emit_insn (gen_safe_wordmove (op0_lo, op1_lo, op0_hi, op1_hi));
	}

      DONE;
    }
})

; This is a single instruction so that it can be recognized more easily by the
; peephole2 that tries to avoid saving/restoring the accumulator.

(define_insn "safe_wordmove"
  [(set (match_operand:QI 0 "mov_dst_operand" "=r,r, r, U,r,U")
	(match_operand:QI 1 "mov_src_operand"  "r,i,hh,hh,U,r"))
   (set (match_operand:QI 2 "mov_dst_operand" "=r,r, r, U,r,U")
	(match_operand:QI 3 "mov_src_operand"  "r,i, r, r,U,r"))]
  "reload_completed && !((MEM_P (operands[0]) && MEM_P (operands[1]))
			 || (MEM_P (operands[2]) && MEM_P (operands[3])))"
  "@
  pha\;lda %1\;sta %0\;lda %3\;sta %2\;pla
  pha\;lda #%1\;sta %0\;lda #%3\;sta %2\;pla
  st%R1 %0\;pha\;lda %3\;sta %2\;pla
  st%R1 %0\;pha\;lda %3\;sta %2\;pla
  pha\;lda %1\;sta %0\;lda %3\;sta %2\;pla
  pha\;lda %1\;sta %0\;lda %3\;sta %2\;pla"
  [(set_attr "length" "10,10,8,10,12,12")])

; We might have a real register free that can be used instead of
; pushing/popping the accumulator for safe_wordmove instructions.

(define_peephole2
  [(match_scratch:QI 4 "hh")
   (parallel [(set (match_operand:QI 0 "mov_dst_operand" "")
		   (match_operand:QI 1 "mov_src_operand" ""))
	      (set (match_operand:QI 2 "mov_dst_operand" "")
		   (match_operand:QI 3 "mov_src_operand" ""))])]
  ""
  [(set (match_dup 4) (match_dup 1))
   (set (match_dup 0) (match_dup 4))
   (set (match_dup 4) (match_dup 3))
   (set (match_dup 2) (match_dup 4))])

(define_insn "loadhi_immed_postreload"
  [(set (match_operand:HI 0 "register_operand" "=hc,r")
	(unspec:HI [(match_operand:HI 1 "immediate_operand" "i,i")]
		   UNSPEC_LOADHI_IMMED_PR))]
  "reload_completed"
  "@
  ld%R0 #>%1\;st%R0 _%R0h\;ld%R0 #<%1
  pha\;lda #>%1\;sta %h0\;lda #<%1\;sta %0\;pla"
  [(set_attr "length" "6,10")])

; If there's a hard register available, do away with the stack push/pop.

(define_peephole2
  [(match_scratch:QI 2 "hh")
   (set (match_operand:HI 0 "zp_reg_operand" "=r")
	(unspec:HI [(match_operand:HI 1 "immediate_operand" "i")]
		   UNSPEC_LOADHI_IMMED_PR))]
  ""
  [(parallel [(set (match_dup 0)
		   (unspec:HI [(match_dup 1)] UNSPEC_LOADHI_IMMED))
	      (clobber (match_dup 2))])])

(define_insn "storehi_lowpart"
  [(set (mem:QI (lo_sum:HI (match_operand:HI 0 "zp_reg_operand"     "r")
			   (match_operand:HI 1 "const_byte_amount"  "I")))
	(truncate:QI (match_operand:HI 2 "accumulator_operand"     "Ac")))
   (set (match_operand:QI 3 "y_reg_operand" "=yh")
	(truncate:QI (match_dup 1)))]
  ""
  "ldy #%1\;sta (%0),y"
  [(set_attr "length" "4")])

(define_insn "storehi_highpart"
  [(set (mem:QI (lo_sum:HI (match_operand:HI 0 "zp_reg_operand" "r")
			   (match_operand:HI 1 "const_byte_amount" "I")))
	(truncate:QI (lshiftrt:HI (match_operand:HI 2 "accumulator_operand"
									  "Ac")
				  (const_int 8))))
   (set (match_operand:QI 3 "y_reg_operand" "=yh")
	(truncate:QI (match_dup 1)))
   (clobber (match_scratch:QI 4 "=Ah"))]
  ""
  "lda _ah\;ldy #%1\;sta (%0),y"
  [(set_attr "length" "6")])

(define_insn "storehi_constmem"
  [(set (match_operand:HI 0 "const_mem_operand" "=U")
	(match_operand:HI 1 "hard_reg_operand" "hc"))
   (clobber (match_scratch:QI 2 "=hh"))]
  ""
  "st%R1 %0\;ld%R2 _%R1h\;st%R2 %0+1"
  [(set_attr "length" "8")])

(define_insn "loadhi_lowpart"
  [(set (match_operand:HI 0 "accumulator_operand" "=Ac")
	(ior:HI
	  (zero_extend:HI
	    (mem:QI (lo_sum:HI (match_operand:HI 1 "zp_reg_operand" "r")
			       (match_operand:HI 2 "const_byte_amount" "I"))))
	  (and:HI (match_operand:HI 3 "accumulator_operand" "0")
		  (const_int 65280))))
   (set (match_operand:QI 4 "y_reg_operand" "=yh")
	(truncate:QI (match_dup 2)))]
  ""
  "ldy #%2\;lda (%1),y"
  [(set_attr "length" "4")])

(define_insn "loadhi_highpart"
  [(set (match_operand:HI 0 "accumulator_operand" "=Ac")
	(mult:HI
	  (zero_extend:HI
	    (mem:QI (lo_sum:HI (match_operand:HI 1 "zp_reg_operand" "r")
			       (match_operand:HI 2 "const_byte_amount" "I"))))
	  (const_int 257)))
   (set (match_operand:QI 3 "y_reg_operand" "=yh")
	(truncate:QI (match_dup 2)))]
  ""
  "ldy #%2\;lda (%1),y\;sta _ah"
  [(set_attr "length" "6")])

(define_insn "loadhi_constmem"
  [(set (match_operand:HI 0 "hard_reg_operand" "=hc")
	(unspec:HI [(match_operand:HI 1 "const_mem_operand" "U")]
		   UNSPEC_LOADHI_CONSTMEM))]
  ""
  "ld%R0 %1+1\;st%R0 _%R0h\;ld%R0 %1"
  [(set_attr "length" "3")])

(define_insn "loadhi_immed"
  [(set (match_operand:HI 0 "register_operand" "=hc,r")
	(unspec:HI [(match_operand:HI 1 "immediate_operand" "i,i")]
		   UNSPEC_LOADHI_IMMED))
   (clobber (match_scratch:QI 2 "=X,hh"))]
  ""
  "@
  ld%R0 #>%1\;st%R0 _%R0h\;ld%R0 #<%1
  ld%R2 #>%1\;st%R2 %h0\;ld%R2 #<%1\;st%R2 %0"
  [(set_attr "length" "6,8")])

(define_expand "reload_inhi_indexreg"
  [(parallel [(set (match_operand:HI 0 "zp_reg_operand" "")
		   (match_operand:HI 1 "register_operand" ""))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=hh"))])]
  ""
{})

(define_insn "movhi_reg"
  [(set (match_operand:HI 0 "register_operand" "=Ac,Ac,Ac,xc,xc,yc,yc,hc, r,r")
	(match_operand:HI 1 "register_operand"  "Ac,xc,yc,xc,Ac,Ac,yc, r,hc,r"))
   (clobber (match_scratch:QI 2 "=X,X,X,X,X,X,X,X,hh,hh"))]
  "m65x_valid_mov_operands (HImode, operands)"
  "@
  nop ; A->A
  lda _xh\;sta _ah\;txa
  lda _yh\;sta _ah\;tya
  nop ; X->X
  ldx _ah\;stx _xh\;tax
  ldy _ah\;sty _yh\;tay
  nop ; Y->Y
  ld%R0 %h1\;st%R0 _%R0h\;ld%R0 %1
  st%R1 %0\;ld%R2 _%R1h\;st%R2 %h0
  ld%R2 %1\;st%R2 %0\;ld%R2 %h1\;st%R2 %h0"
  [(set_attr "length" "2,5,5,2,5,5,2,6,6,8")])

(define_insn "storehi_indirect_indexed"
  [(set (match_operand:HI 0 "memory_operand" "=m")
	(match_operand:HI 1 "accumulator_operand" "Ac"))
   (clobber (reg:QI Y_REGNUM))
   (clobber (reg:QI ACC_REGNUM))]
  "reload_completed"
  "sta %0\;lda _ah\;iny\;sta %0"
  [(set_attr "length" "7")])

(define_insn "loadhi_indirect_indexed"
  [(set (match_operand:HI 0 "accumulator_operand" "=Ac")
	(match_operand:HI 1 "memory_operand" "m"))
   (clobber (reg:QI Y_REGNUM))]
  "reload_completed"
  "lda %1\;sta _ah\;dey\;lda %1"
  [(set_attr "length" "7")])

; HImode arithmetic.

(define_insn "addhi3"
  [(set (match_operand:HI 0 "zp_reg_or_acc_operand"
					       "=r, r,Ac,Ac,Ac,Ac,r,r,r,r")
	(plus:HI (match_operand:HI 1 "zp_reg_or_acc_operand"
					       "%r,Ac, 0, 0, 0, 0,r,0,0,r")
		 (match_operand:HI 2 "addhi_op2"
					       "Ac, i, r, K, I, i,r,K,I,i")))]
  ""
  "@
  pha\;clc\;adc %1\;sta %0\;lda _ah\;adc %h1\;sta %h0\;pla
  pha\;clc\;adc #<%2\;sta %0\;lda _ah\;adc #>%2\;sta %h0\;pla
  clc\;adc %2\;pha\;lda _ah\;adc %h2\;sta _ah\;pla
  inc a\;bne :+\;inc _ah\;:
  clc\;adc #%2\;bcc :+\;inc _ah\;:
  clc\;adc #<%2\;pha\;lda _ah\;adc #>%2\;sta _ah\;pla
  pha\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;pla
  inc %0\;bne :+\;inc %h0\;:
  pha\;lda %0\;clc\;adc #%2\;sta %0\;bcc :+\;inc %h0\;:\;pla
  pha\;lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0\;pla"
  [(set_attr "length" "13,13,11,5,7,11,15,6,13,15")])

; If destination is a ZP register, we might not need the value in the
; accumulator afterwards so we can get away with not saving it.

(define_peephole2
  [(set (match_operand:HI 0 "strict_zp_reg_operand" "")
	(plus:HI (match_operand:HI 1 "zp_reg_or_acc_operand" "")
		 (match_operand:HI 2 "nonmemory_operand" "")))
   (match_scratch:QI 3 "Ah")]
  ""
  [(parallel [(set (match_dup 0) (plus:HI (match_dup 1) (match_dup 2)))
	      (clobber (match_dup 3))])]
  "")

; These adds clobber the accumulator.

(define_insn "addhi3_zp_clob_acc"
  [(set (match_operand:HI 0 "zp_reg_operand"		     "=r, r,r,r,r,r")
	(plus:HI (match_operand:HI 1 "zp_reg_or_acc_operand" "%r,Ac,r,0,0,r")
		 (match_operand:HI 2 "nonmemory_operand"     "Ac, i,r,K,I,i")))
   (clobber (match_scratch:QI 3 "=Ah,Ah,Ah,X,Ah,Ah"))]
  ""
  "@
  clc\;adc %1\;sta %0\;lda _ah\;adc %h1\;sta %h0
  clc\;adc #<%2\;sta %0\;lda _ah\;adc #>%2\;sta %h0
  lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0
  inc %0\;bne :+\;inc %h0\;:
  lda %0\;clc\;adc #%2\;sta %0\;bcc :+\;inc %h0\;:
  lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0"
  [(set_attr "length" "11,11,13,6,11,13")])

(define_insn "*lo_sum_addr"
  [(set (match_operand:HI 0 "zp_reg_operand" "=r")
	(lo_sum:HI (match_operand:HI 1 "zp_reg_operand" "0")
	  (zero_extend:HI (match_operand:QI 2 "y_reg_operand" "yh"))))]
  ""
  "pha\;tya\;clc\;adc %1\;sta %0\;bcc :+\;inc %h1\;:\;pla"
  [(set_attr "length" "12")])

(define_insn "*lo_sum_const"
  [(set (match_operand:HI 0 "zp_reg_operand" "=r")
	(lo_sum:HI (match_operand:HI 1 "zp_reg_operand" "0")
		   (match_operand:HI 2 "const_byte_amount" "I")))]
  ""
  "pha\;lda %1\;clc\;adc #%2\;sta %1\;bcc :+\;inc %h1\;:\;pla"
  [(set_attr "length" "13")])

(define_insn "lshrhi3"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
	(lshiftrt:HI (match_operand:HI 1 "accumulator_operand"	  "0, 0")
		     (match_operand:HI 2 "shifthi_amount"	 "Nr,Nc")))
   (clobber (match_scratch:QI 3 "=X,&jh"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "lsr _ah\;ror a";
    case 2: return "lsr _ah\;ror a\;lsr _ah\;ror a";
    case 3: return "lsr _ah\;ror a\;lsr _ah\;ror a\;lsr _ah\;ror a";
    case 4: return "lsr _ah\;ror a\;lsr _ah\;ror a\;lsr _ah\;ror a\;"
		   "lsr _ah\;ror a";
    case 5:
      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
	     "and #7\;ld%R3 _ah\;sta _ah\;t%R3a";
    case 6:
      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;"
	     "and #3\;ld%R3 _ah\;sta _ah\;t%R3a";
    case 7:
      return "asl a\;rol _ah\;lda _ah\;stz _ah\;rol _ah";
    case 8: return "lda _ah\;stz _ah";
    case 9: return "lda _ah\;ror a\;stz _ah";
    case 10: return "lda _ah\;ror a\;ror a\;stz _ah";
    case 11: return "lda _ah\;ror a\;ror a\;ror a\;stz _ah";
    case 12: return "lda _ah\;ror a\;ror a\;ror a\;ror a\;stz _ah";
    case 13:
      return "lda #0\;asl _ah\;rol a\;asl _ah\;rol a\;asl _ah\;rol a\;stz _ah";
    case 14: return "lda #0\;asl _ah\;rol a\;asl _ah\;rol a\;stz _ah";
    case 15: return "lda #0\;asl _ah\;rol a\;stz _ah";
    case 16: return "lda #0\;sta _ah";
    default: gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
	       (eq (match_dup 2) (const_int 2)) (const_int 6)
	       (eq (match_dup 2) (const_int 3)) (const_int 9)
	       (eq (match_dup 2) (const_int 4)) (const_int 12)
	       (eq (match_dup 2) (const_int 5)) (const_int 18)
	       (eq (match_dup 2) (const_int 6)) (const_int 15)
	       (eq (match_dup 2) (const_int 7)) (const_int 9)
	       (eq (match_dup 2) (const_int 8)) (const_int 4)
	       (eq (match_dup 2) (const_int 9)) (const_int 5)
	       (eq (match_dup 2) (const_int 10)) (const_int 6)
	       (eq (match_dup 2) (const_int 11)) (const_int 7)
	       (eq (match_dup 2) (const_int 12)) (const_int 8)
	       (eq (match_dup 2) (const_int 13)) (const_int 13)
	       (eq (match_dup 2) (const_int 14)) (const_int 10)
	       (eq (match_dup 2) (const_int 15)) (const_int 7)
	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
	      (const_int 0)))])

; This can support more addressing modes!

(define_insn "lshrhi3_addhi"
  [(set (match_operand:HI 0 "zp_reg_operand"				"=r")
	(plus:HI (lshiftrt:HI (match_operand:HI 1 "accumulator_operand"  "Ac")
			      (match_operand:HI 2 "shifthi_rt_byteswap"  "Nc"))
		 (match_operand:HI 3 "zp_reg_operand"			 "r")))
   (clobber (match_scratch:QI 4 "=Ah"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 5:
      return "asl _ah\;rol a\;asl _ah\;rol a\;asl _ah\;rol a\;and #7\;"
	     "pha\;lda %3\;clc\;adc _ah\;sta %0\;pla\;adc %h3\;sta %h0";
    case 6:
      return "asl a\;rol _ah\;php\;asl a\;rol _ah\;pla\;asl a\;adc #0\;and #3\;"
	     "pha\;lda %3\;clc\;adc _ah\;sta %0\;pla\;adc %h3\;sta %h0";
    default:
      gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 5)) (const_int 24)
	       (eq (match_dup 2) (const_int 6)) (const_int 26)]
	      (const_int 0)))])

(define_insn "ashlhi3"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
	(ashift:HI (match_operand:HI 1 "accumulator_operand"	 "0, 0")
		   (match_operand:HI 2 "shifthi_amount"		 "Nl,Nx")))
   (clobber (match_scratch:QI 3 "=X,&jh"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "asl a\;rol _ah";
    case 2: return "asl a\;rol _ah\;asl a\;rol _ah";
    case 3: return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah";
    case 4: return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;"
		   "asl a\;rol _ah";
    case 5:
      return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;"
	     "asl a\;rol _ah";
    case 6:
      return "ta%R3\;lda _ah\;ror a\;t%R3a\;ror a\;ror _ah\;ror a\;"
	     "ror _ah\;ta%R3\;lda _ah\;and #$c0\;st%R3 _ah";
    case 7: return "lsr _ah\;ror a\;sta _ah\;lda #0\;ror a";
    case 8: return "sta _ah\;lda #0";
    case 9: return "asl a\;sta _ah\;lda #0";
    case 10: return "asl a\;asl a\;sta _ah\;lda #0";
    case 11: return "asl a\;asl a\;asl a\;sta _ah\;lda #0";
    case 12: return "asl a\;asl a\;asl a\;asl a\;sta _ah\;lda #0";
    case 13: return "lsr a\;ror a\;ror a\;ror a\;and #$e0\;sta _ah\;lda #0";
    case 14: return "lsr a\;ror a\;ror a\;and #$c0\;sta _ah\;lda #0";
    case 15: return "lsr a\;lda #0\;sta _ah\;ror _ah";
    case 16: return "lda #0\;sta _ah";
    }
  return "";
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
	       (eq (match_dup 2) (const_int 2)) (const_int 6)
	       (eq (match_dup 2) (const_int 3)) (const_int 9)
	       (eq (match_dup 2) (const_int 4)) (const_int 12)
	       (eq (match_dup 2) (const_int 5)) (const_int 15)
	       (eq (match_dup 2) (const_int 6)) (const_int 18)
	       (eq (match_dup 2) (const_int 7)) (const_int 8)
	       (eq (match_dup 2) (const_int 8)) (const_int 4)
	       (eq (match_dup 2) (const_int 9)) (const_int 5)
	       (eq (match_dup 2) (const_int 10)) (const_int 6)
	       (eq (match_dup 2) (const_int 11)) (const_int 7)
	       (eq (match_dup 2) (const_int 12)) (const_int 8)
	       (eq (match_dup 2) (const_int 13)) (const_int 10)
	       (eq (match_dup 2) (const_int 14)) (const_int 9)
	       (eq (match_dup 2) (const_int 15)) (const_int 7)
	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
	      (const_int 0)))])

(define_insn "ashrhi3"
  [(set (match_operand:HI 0 "accumulator_operand"		"=Ac,Ac")
	(ashiftrt:HI (match_operand:HI 1 "accumulator_operand"   "0, 0")
		     (match_operand:HI 2 "shifthi_amount"	 "Na,Nb")))
   (clobber (match_scratch:QI 3 "=&jh,X"))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a";
    case 2:
      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
	     "ror a";
    case 3:
      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
	     "ror a\;cp%R3 #$80\;ror _ah\;ror a";
    case 4:
      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
	     "ror a\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;ror a";
    case 5:
      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
	     "and #7\;ld%R3 _ah\;sta _ah\;and #4\;beq :+\;lda _ah\;ora #$f8\;"
	     "sta _ah\;:\;t%R3a";
    case 6:
      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;and #3\;ld%R3 _ah\;"
	     "sta _ah\;and #2\;beq :+\;lda _ah\;ora #$fc\;sta _ah\;:\;t%R3a";
    case 7:
      return "cmp #$80\;rol _ah\;lda #0\;sbc #0\;eor #$ff\;ld%R3 _ah\;sta _ah\;"
	     "t%R3a";
    case 8:
      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a";
    case 9:
      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
	     "cmp #$80\;ror a";
    case 10:
      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
	     "cmp #$80\;ror a\;cmp #$80\;ror a";
    case 11:
      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
    case 12:
      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;"
	     "ror a";
    case 13:
      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
	     "asl _ah\;rol a\;asl _ah\;rol a\;st%R3 _ah";
    case 14:
      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
	     "asl _ah\;rol a\;st%R3 _ah";
    case 15:
    case 16:
      return "asl _ah\;lda #0\;sbc #0\;eor #$ff\;sta _ah";
    }
  return "";
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 7)
	       (eq (match_dup 2) (const_int 2)) (const_int 12)
	       (eq (match_dup 2) (const_int 3)) (const_int 17)
	       (eq (match_dup 2) (const_int 4)) (const_int 22)
	       (eq (match_dup 2) (const_int 5)) (const_int 28)
	       (eq (match_dup 2) (const_int 6)) (const_int 25)
	       (eq (match_dup 2) (const_int 7)) (const_int 15)
	       (eq (match_dup 2) (const_int 8)) (const_int 12)
	       (eq (match_dup 2) (const_int 9)) (const_int 15)
	       (eq (match_dup 2) (const_int 10)) (const_int 18)
	       (eq (match_dup 2) (const_int 11)) (const_int 21)
	       (eq (match_dup 2) (const_int 12)) (const_int 24)
	       (eq (match_dup 2) (const_int 13)) (const_int 20)
	       (eq (match_dup 2) (const_int 14)) (const_int 17)
	       (eq (match_dup 2) (const_int 15)) (const_int 10)
	       (eq (match_dup 2) (const_int 16)) (const_int 10)]
	      (const_int 0)))])

(define_expand "cbranchhi4"
  [(parallel
    [(set (pc) (if_then_else
		 (match_operator 0 "himode_comparison"
	           [(match_operand:HI 1 "mov_src_operand" "")
		    (match_operand:HI 2 "mov_src_operand" "")])
		 (label_ref (match_operand 3 "" ""))
		 (pc)))
     (clobber (match_scratch:QI 4 ""))])]
  ""
{
  int force_reg_operand;

  switch (GET_CODE (operands[0]))
    {
    case GTU:
    case LEU:
    case GT:
    case LE:
      force_reg_operand = 2;
      break;

    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      force_reg_operand = 1;
      break;

    default:
      gcc_unreachable ();
    }

  if (can_create_pseudo_p () &&
      !register_operand (operands[force_reg_operand], HImode))
    operands[force_reg_operand] = force_reg (HImode,
					     operands[force_reg_operand]);
})

(define_insn_and_split "cbrhi_eq"
  [(set (pc) (if_then_else
	       (eq (match_operand:HI 0 "register_operand" "hc,hc,hc,r,r")
		   (match_operand:HI 1 "mov_src_operand"   "r, i, U,r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hh,hh,hh,hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (EQ, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ne"
  [(set (pc) (if_then_else
	       (ne (match_operand:HI 0 "register_operand" "hc,hc,hc,r,r")
		   (match_operand:HI 1 "mov_src_operand"   "r, i, U,r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hh,hh,hh,hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (NE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ltu"
  [(set (pc) (if_then_else
	       (ltu (match_operand:HI 0 "register_operand" "hc,hc,r,hc,r")
		    (match_operand:HI 1 "mov_src_operand"   "r, i,i, U,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=&hh,&hh,hh,&hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gtu"
  [(set (pc) (if_then_else
	       (gtu (match_operand:HI 0 "mov_src_operand"   "r, i,i, U,r")
		    (match_operand:HI 1 "register_operand" "hc,hc,r,hc,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=&hh,&hh,hh,&hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_geu"
  [(set (pc) (if_then_else
	       (geu (match_operand:HI 0 "register_operand"      "hc,hc,r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand"  "r, i,r,i"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=&hh,&hh,hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_leu"
  [(set (pc) (if_then_else
	       (leu (match_operand:HI 1 "zp_reg_or_imm_operand" "r,r,i")
		    (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i,r"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hh,hh,hh"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_lt"
  [(set (pc) (if_then_else
	       (lt (match_operand:HI 0 "register_operand" "hc,hc,r,r")
		   (match_operand:HI 1 "mov_src_operand"   "r, i,r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Ah,Ah,Ah,Ah"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gt"
  [(set (pc) (if_then_else
	       (gt (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Ah,Ah"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ge"
  [(set (pc) (if_then_else
	       (ge (match_operand:HI 0 "register_operand" "hc,hc,r,r")
		   (match_operand:HI 1 "mov_src_operand"   "r, i,r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Ah,Ah,Ah,Ah"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_le"
  [(set (pc) (if_then_else
	       (le (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Ah,Ah"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

; QImode operations.

(define_expand "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
{
  if (can_create_pseudo_p ()
      && memory_operand (operands[0], QImode)
      && (memory_operand (operands[1], QImode)
	  || (GET_CODE (operands[1]) == CONST_INT
	      && (INTVAL (operands[1]) != 0
		  || !CONSTANT_ADDRESS_P (XEXP (operands[0], 0))))
	  || (!CONSTANT_ADDRESS_P (XEXP (operands[0], 0)) && REG_P (operands[1])
	      && REGNO (operands[1]) != ACC_REGNUM)))
    operands[1] = copy_to_mode_reg (QImode, operands[1]);
})

(define_insn "*movqi_insn"
  [(set (match_operand:QI 0 "mov_dst_operand"
		       "=hh,Ah,jh,Ah,xh,yh,hh, r,hh, U,Ah, m,r,U,r,xh,yh")
	(match_operand:QI 1 "mov_src_operand"
			 "i,jh,Ah,Ah,xh,yh, r,hh, U,hh, m,Ah,z,z,r,yh,xh"))]
  "m65x_valid_mov_operands (QImode, operands)"
  "@
  ld%R0 #%1
  t%R1a
  ta%R0
  nop
  nop
  nop
  ld%R0 %1
  st%R1 %0
  ld%R0 %1
  st%R1 %0
  lda %1
  sta %0
  stz %0
  stz %0
  pha\;lda %1\;sta %0\;pla
  phy\;plx
  phx\;ply"
 [(set_attr "length" "2,1,1,2,2,2,2,2,3,3,2,2,2,3,6,2,2")])

; Opportunistically clean up sequences in movqi pattern which use pha/pla.

(define_peephole2
  [(match_scratch:QI 2 "hh")
   (set (match_operand:QI 0 "zp_reg_or_const_mem_operand" "")
	(match_operand:QI 1 "zp_reg_or_const_mem_operand" ""))]
  ""
  [(parallel [(set (match_dup 0) (match_dup 1))
	      (clobber (match_dup 2))])]
  "")

(define_insn "zp_clob_hardreg_movqi"
  [(set (match_operand:QI 0 "zp_reg_or_const_mem_operand" "=r,U,r,U")
	(match_operand:QI 1 "zp_reg_or_const_mem_operand"  "r,r,U,U"))
   (clobber (match_scratch:QI 2 "=hh,hh,hh,hh"))]
  ""
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4,5,5,6")])

(define_insn "pushqi1"
  [(set (reg:QI HARDSP_REGNUM) (plus:QI (reg:QI HARDSP_REGNUM) (const_int -1)))
   (set (mem:QI (reg:QI HARDSP_REGNUM))
	(match_operand:QI 0 "hard_reg_operand" "hh"))]
  ""
  "ph%R0"
  [(set_attr "length" "1")])

(define_insn "popqi1"
  [(set (reg:QI HARDSP_REGNUM) (plus:QI (reg:QI HARDSP_REGNUM) (const_int 1)))
   (set (match_operand:QI 0 "hard_reg_operand" "=hh")
	(mem:QI (plus:QI (reg:QI HARDSP_REGNUM) (const_int 1))))]
  ""
  "pl%R0"
  [(set_attr "length" "1")])

(define_expand "reload_inoutqi_zp"
  [(parallel [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
		   (match_operand:QI 1 "reload_zpreg_operand" "r"))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=hh"))])]
  ""
{
})

(define_insn "movqi_loadstore_zp"
  [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
	(match_operand:QI 1 "reload_zpreg_operand" "r"))
   (clobber (match_scratch:QI 2 "=hh"))]
  ""
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4")])

(define_insn "addqi3"
  [(set (match_operand:QI 0 "hard_reg_operand"
					     "=Ah,Ah,Ah,Ah,xh,yh,Ah,xh,yh")
	(plus:QI (match_operand:QI 1 "hard_reg_operand"
					      "%0, 0, 0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
					       "r, m, K, I, K, K, M, L, L")))]
  ""
  "@
  clc\;adc %2
  clc\;adc %2
  inc a
  clc\;adc #%2
  inx
  iny
  sec\;sbc #%2
  dex
  dey"
  [(set_attr "length" "3,3,1,3,1,1,3,1,1")])

(define_insn "subqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	    "=Ah,Ah")
	(minus:QI (match_operand:QI 1 "accumulator_operand"   "0, 0")
		  (match_operand:QI 2 "memory_operand"	      "r, m")))]
  ""
  "@
  sec\;sbc %2
  sec\;sbc %2"
  [(set_attr "length" "3")])

(define_insn "sbcqi3_nv"
  [(set (match_operand:QI 0 "accumulator_operand" "=Ah,Ah")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand" "0,0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand" "r,i")
		    (minus:QI (const_int 1)
			      (ne:QI (reg:CC_C CC_REGNUM) (const_int 0))))))
   (set (reg:CC_NV CC_REGNUM)
	(unspec:CC_NV [(match_dup 0) (match_dup 2) (reg:CC_C CC_REGNUM)]
		      UNSPEC_SBC_OVF))]
  ""
  "@
  sbc %2
  sbc #%2"
  [(set_attr "length" "2,2")])

(define_insn "negate_highbit"
  [(set (match_operand:QI 0 "accumulator_operand" "=Ah")
	(xor:QI (match_operand:QI 1 "accumulator_operand" "0")
		(const_int 128)))
   (set (reg:CC_NV CC_REGNUM)
	(unspec:CC_NV [(match_dup 0) (reg:CC_NV CC_REGNUM)] UNSPEC_NEG_HIBIT))]
  ""
  "eor #$80\t; negate top bit"
  [(set_attr "length" "2")])

(define_insn "andqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Ah,Ah,Ah")
	(and:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "memory_operand"	    "r, m, I")))]
  ""
  "and %2
   and %2
   and #%2"
  [(set_attr "length" "2")])

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Ah,Ah,Ah")
	(ior:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "memory_operand"	    "r, m, I")))]
  ""
  "ora %2
   ora %2
   ora #%2"
  [(set_attr "length" "2")])

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Ah,Ah,Ah")
	(xor:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "memory_operand"	    "r, m, I")))]
  ""
  "eor %2
   eor %2
   eor #%2"
  [(set_attr "length" "2")])

(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	     "=Ah")
	(ashift:QI (match_operand:QI 1 "accumulator_operand"  "0")
		   (match_operand:QI 2 "shiftqi_amount"       "NB")))]
  ""
  "asl * %2"
  [(set_attr "length" "1")])

(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	       "=Ah")
	(lshiftrt:QI (match_operand:QI 1 "accumulator_operand"  "0")
		     (match_operand:QI 2 "shiftqi_amount"       "NB")))]
  ""
  "lsr * %2"
  [(set_attr "length" "1")])

(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	       "=Ah")
	(ashiftrt:QI (match_operand:QI 1 "accumulator_operand"  "0")
		     (match_operand:QI 2 "shiftqi_amount"       "NB")))]
  ""
  "cmp #$80\;ror * %2"
  [(set_attr "length" "1")])

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "accumulator_operand" "=Ah")
	(match_operand:QI 1 "accumulator_operand"   "0"))]
  ""
  "eor #$ff"
  [(set_attr "length" "2")])

; Comparisons.

(define_mode_iterator CMPQI [CC CC_C])

(define_insn "compareqi_<mode>"
  [(set (reg:CMPQI CC_REGNUM)
	(compare:CMPQI (match_operand:QI 0 "hard_reg_operand"    "hh,hh,hh")
		       (match_operand:QI 1 "compareqi_src_operand"
								  "r, I, U")))]
  ""
  "@
  %C0 %1
  %C0 #%1
  %C0 %1"
  [(set_attr "length" "2,2,3")])

; Jumps & calls.

(define_mode_iterator CBRQI [CC CC_NV])
(define_mode_attr signedness [(CC "uns") (CC_NV "sgn")])

(define_insn "condbranchqi_<mode>"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_<signedness>_comparison"
			[(reg:CBRQI CC_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (<MODE>mode, operands[0], operands[1]);
  return "";
}
  [(set_attr "length" "2")])

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "zp_reg_operand" "Ac,r"))]
  ""
  "@
  pha\;lda _ah\;pha\;php\;rti
  jmp (%0)"
  [(set_attr "length" "6,2")])

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0"
  [(set_attr "length" "3")])

(define_insn "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "himode_comparison"
		 [(match_operand:QI 1 "mov_src_operand"	"")
		  (match_operand:QI 2 "mov_src_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  ""
  "cmp foo\;bxx %3"
  [(set_attr "length" "4")])

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use (const_int 0))])])

(define_insn "call_sym"
  [(call (mem:QI (match_operand:HI 0 "" ""))
  	 (match_operand 1 "" ""))
   (use (const_int 0))]
  "GET_CODE (operands[0]) == SYMBOL_REF"
  "jsr %0"
  [(set_attr "length" "3")])

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
        	   (call (match_operand 1 "memory_operand" "")
  			 (match_operand 2 "general_operand" "")))
	      (use (const_int 0))])])

(define_insn "call_value_sym"
  [(set (match_operand 0 "" "")
        (call (mem:QI (match_operand:HI 1 "" ""))
  	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  "GET_CODE (operands[1]) == SYMBOL_REF"
  "jsr %1"
  [(set_attr "length" "3")])

(define_insn "return"
  [(return)]
  ""
  "rts"
  [(set_attr "length" "1")])
