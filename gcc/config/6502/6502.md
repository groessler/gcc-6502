; Register constraints (not finalised)
; A -- hard accumulator reg
; x -- hard X reg
; y -- hard Y reg
; h -- all hard regs
; r -- general regs
; S -- stack reg

(include "constraints.md")
(include "predicates.md")

(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand"
	  "=A,x,y,A,A,x,y,A,r,x,r,y,r,A,m,x,m,y,m")
	(match_operand:QI 1 "general_operand"
	  " I,I,I,x,y,A,A,r,A,r,x,r,y,m,A,m,x,m,y"))]
  ""
  "@
  lda #%1
  ldx #%1
  ldy #%1
  txa
  tya
  tax
  tay
  lda %1
  sta %0
  ldx %1
  stx %0
  ldy %1
  sty %0
  lda %1
  sta %0
  ldx %1
  stx %1
  ldy %1
  sty %1")

(define_insn "movhi"
  [(set (match_operand:HI 0 "movhi_dst_operand"	"=h,A,j,h,?r,U,A,r,U,r")
	(match_operand:HI 1 "movhi_src_operand"	 "J,j,A,r,?A,A,U,r,r,U"))]
  ""
{
  switch (which_alternative)
    {
    case 0:
      switch (REGNO (operands[0]))
        {
	case ACC_REGNUM: return "lda #>%1\;sta ah\;lda #<%1";
	case X_REGNUM: return "ldx #>%1\;stx xh\;ldx #<%1";
	case Y_REGNUM: return "ldy #>%1\;sty yh\;ldx #<%1";
	default: gcc_unreachable ();
	}
      break;
    
    case 1:
      switch (REGNO (operands[1]))
        {
	case X_REGNUM: return "lda xh\;sta ah\;txa";
	case Y_REGNUM: return "lda yh\;sta ah\;tya";
	default: gcc_unreachable ();
	}
      break;
    
    case 2:
      switch (REGNO (operands[0]))
        {
	case X_REGNUM: return "ldx ah\;stx xh\;tax";
	case Y_REGNUM: return "ldy ah\;sty yh\;tay";
	default: gcc_unreachable ();
	}
      break;
    
    case 3:
      switch (REGNO (operands[0]))
        {
	case ACC_REGNUM: return "lda %h1\;sta ah\;lda %1";
	case X_REGNUM: return "ldx %h1\;stx xh\;ldx %1";
	case Y_REGNUM: return "ldy %h1\;sty yh\;ldy %1";
	default: gcc_unreachable ();
	}
      break;
    
    case 4:
      /* We can't store the accumulator without clobbering it.  If accumulator
	 is dead after the insn, we can use a peephole2 to avoid preserving
	 it.  */
      return "pha\;lda ah\;sta %h0\;pla\;sta %0";
    
    case 5:
    case 7:
    case 8:
    case 9:
      return "%0 := %1";
    
    case 6:
      return "lda %1+1\;sta ah\;lda %1";
    
    default:
      gcc_unreachable ();
    }
  
  return "";
})

; This peephole improves accumulator-storing if the value is dead after the
; insn.

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "=r")
	(match_operand:HI 1 "accumulator_operand" "A"))
   (match_scratch:QI 2 "A")]
  ""
  [(parallel [(set (match_dup 0) (match_dup 1))
	      (clobber (match_dup 2))])]
  "")

(define_insn "store_clobber_acc_to_zp"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(match_operand:HI 1 "accumulator_operand" "A"))
   (clobber (match_scratch:QI 2 "=A"))]
  ""
  "sta %0\;lda ah\;sta %h0")

; Store Y to indirect-Y location.  This one must preserve hard registers.

(define_insn "movhi_sty_indy"
  [(set (mem:HI (plus:HI (match_operand:HI 0 "register_operand" "r")
			 (match_operand:HI 1 "immediate_operand" "I")))
	(match_operand:HI 2 "y_reg_operand" "y"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[1]);
  
  operands[1] = GEN_INT (offset + 1);
  
  return "pha\;tya\;pha\;ldy #%1\;lda yh\;sta (%0),y\;pla\;dey\;"
	 "sta (%0),y\;tay\;pla";
})

; Load Y from indirect-Y location.  This must preserve hard registers too.

(define_insn "movhi_ldy_indy"
  [(set (match_operand:HI 0 "y_reg_operand" "=y")
	(mem:HI (plus:HI (match_operand:HI 1 "register_operand" "r")
			 (match_operand:HI 2 "immediate_operand" "I"))))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[2]);
  
  operands[2] = GEN_INT (offset + 1);
  
  return "pha\;ldy #%2\;lda (%1),y\;sta yh\;dey\;lda (%1),y\;tay\;pla";
})

(define_insn "addhi3"
  [(set (match_operand:HI 0 "reg_or_acc_operand"	  "=r,r,A,A,r,r")
	(plus:HI (match_operand:HI 1 "reg_or_acc_operand" "%r,A,0,0,r,r")
		 (match_operand:HI 2 "nonmemory_operand"   "A,J,r,J,r,J")))]
  ""
  "@
  pha\;clc\;adc %1\;sta %0\;lda ah\;adc %h1\;sta %h0\;pla
  pha\;clc\;adc #<%2\;sta %0\;lda ah\;adc #>%2\;sta %h0\;pla
  clc\;adc %2\;pha\;lda ah\;adc %h2\;sta ah\;pla
  clc\;adc #<%2\;pha\;lda ah\;adc #>%2\;sta ah\;pla
  pha\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;pla
  pha\;lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0\;pla")

; If destination is a ZP register, we might not need the value in the
; accumulator afterwards so we can get away with not saving it.

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_operand:HI 1 "reg_or_acc_operand" "")
		 (match_operand:HI 2 "nonmemory_operand" "")))
   (match_scratch:QI 3 "A")]
  ""
  [(parallel [(set (match_dup 0) (plus:HI (match_dup 1) (match_dup 2)))
	      (clobber (match_dup 3))])]
  "")

; These adds clobber the accumulator.

(define_insn "addhi3_zp_clob_acc"
  [(set (match_operand:HI 0 "register_operand"		  "=r,r,r,r")
	(plus:HI (match_operand:HI 1 "reg_or_acc_operand" "%r,A,r,r")
		 (match_operand:HI 2 "nonmemory_operand"   "A,J,r,J")))
   (clobber (match_scratch:QI 3 "=A,A,A,A"))]
  ""
  "@
  clc\;adc %1\;sta %0\;lda ah\;adc %h1\;sta %h0
  clc\;adc #<%2\;sta %0\;lda ah\;adc #>%2\;sta %h0
  lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0
  lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0")

; Load HImode accumulator from indirect or indirect-Y address.

(define_expand "reload_inhi_acc_indy"
  [(parallel [(set (match_operand:HI 0 "accumulator_operand" "=A")
        	   (match_operand:HI 1 "memory_operand" "m"))
	      (clobber (match_operand:QI 2 "y_reg_operand" "=&y"))])]
  ""
{
  if (REG_P (XEXP (operands[1], 0)))
    operands[1] = gen_rtx_MEM (HImode,
		    gen_rtx_PLUS (HImode, operands[1], const0_rtx));
})

(define_insn "load_acc_indy"
  [(set (match_operand:HI 0 "accumulator_operand" "=A")
        (mem:HI (plus:HI (match_operand:HI 1 "register_operand" "r")
			 (match_operand:HI 2 "immediate_operand" "I"))))
   (clobber (match_scratch:QI 3 "=&y"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[2]);

  operands[2] = GEN_INT (offset + 1);

  if (offset == 0)
    return "ldy #1\;lda (%1),y\;sta ah\;lda (%1)";
  else
    return "ldy #%2\;lda (%1),y\;sta ah\;dey\;lda (%1),y";
})

; Store HImode accumulator to indirect or indirect-Y address.

(define_expand "reload_outhi_acc_indy"
  [(parallel [(set (match_operand:HI 0 "memory_operand" "=m")
		   (match_operand:HI 1 "accumulator_operand" "A"))
	      (clobber (match_operand:QI 2 "y_reg_operand" "=&y"))])]
  ""
{
  if (REG_P (XEXP (operands[0], 0)))
    operands[0] = gen_rtx_MEM (HImode,
		    gen_rtx_PLUS (HImode, operands[0], const0_rtx));
})

(define_insn "store_acc_indy"
  [(set (mem:HI (plus:HI (match_operand:HI 0 "register_operand" "r")
			 (match_operand:HI 1 "immediate_operand" "I")))
	(match_operand:HI 2 "accumulator_operand" "A"))
   (clobber (match_scratch:QI 3 "=&y"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[1]);
  
  operands[1] = GEN_INT (offset);

  /* Tsk tsk, we can't clobber two different registers, but really we'd like to
     do so.  Preserve accumulator instead.  */
  if (offset == 0)
    return "sta (%0)\;ldy #1\;pha\;lda ah\;sta (%0),y\;pla";
  else
    return "ldy #%1\;sta (%0),y\;iny\;pha\;lda ah\;sta (%0),y\;pla";
})

; Load HImode ZP register from indirect or indirect-Y address.

(define_expand "reload_inhi_reg_indy"
  [(parallel [(set (match_operand:HI 0 "register_operand" "=r")
        	   (match_operand:HI 1 "memory_operand" "m"))
	      (clobber (match_operand:QI 2 "y_reg_operand" "=&y"))])]
  ""
{
  if (REG_P (XEXP (operands[1], 0)))
    operands[1] = gen_rtx_MEM (HImode,
		    gen_rtx_PLUS (HImode, operands[1], const0_rtx));
})

(define_insn "load_reg_indy"
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(mem:HI (plus:HI (match_operand:HI 1 "register_operand" "r")
			 (match_operand:HI 2 "immediate_operand" "I"))))
   (clobber (match_scratch:QI 3 "=&y"))]
  ""
{
  HOST_WIDE_INT offset = INTVAL (operands[2]);

  operands[2] = GEN_INT (offset + 1);

  if (offset == 0)
    return "pha\;ldy #1\;lda (%1),y\;sta %h0\;lda (%1)\;sta %0\;pla";
  else
    return "pha\;ldy #%2\;lda (%1),y\;sta %h0\;dey\;lda (%1),y\;sta %0\;pla";
})

; Load HImode ZP register from accumulator.

(define_expand "reload_inhi_zp_acc"
  [(parallel [(set (match_operand:HI 0 "register_operand" "=r")
		   (match_operand:HI 1 "accumulator_operand" "A"))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=h"))])])

(define_insn "load_reg_acc"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(match_operand:HI 1 "accumulator_operand" "A"))
   (clobber (match_scratch:QI 2 "=h"))]
  ""
{
  switch (REGNO (operands[2]))
    {
    case ACC_REGNUM: return "sta %0\;lda ah\;sta %h0";
    case X_REGNUM: return "sta %0\;ldx ah\;stx %h0";
    case Y_REGNUM: return "sta %0\;ldy ah\;sty %h0";
    default: gcc_unreachable ();
    }
  
  return "";
})

; QImode arithmetic

(define_insn "addqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A,A,x,y,A,x,y")
	(plus:QI (match_operand:QI 1 "register_operand"	"%0,0,0,0,0,0,0,0,0")
		 (match_operand:QI 2 "general_operand"	" r,m,K,I,K,K,M,L,L")))]
  ""
  "clc\;adc %2
   clc\;adc %2
   inc a
   clc\;adc #%2
   inx
   iny
   sec\;sbc #%2
   dex
   dey")

(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand"		 "=A,A")
	(minus:QI (match_operand:QI 1 "register_operand" " 0,0")
		  (match_operand:QI 2 "memory_operand"	 " r,m")))]
  ""
  "sec\;sbc %2
   sec\;sbc %2")

(define_insn "andqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A")
	(and:QI (match_operand:QI 1 "register_operand"	" 0,0,0")
		(match_operand:QI 2 "memory_operand"	" r,m,I")))]
  ""
  "and %2
   and %2
   and #%2")

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A")
	(ior:QI (match_operand:QI 1 "register_operand"	" 0,0,0")
		(match_operand:QI 2 "memory_operand"	" r,m,I")))]
  ""
  "ora %2
   ora %2
   ora #%2")

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand"		"=A,A,A")
	(xor:QI (match_operand:QI 1 "register_operand"	" 0,0,0")
		(match_operand:QI 2 "memory_operand"	" r,m,I")))]
  ""
  "eor %2
   eor %2
   eor #%2")

(define_insn "ashlqi3"
  [(set (match_operand:QI 0 "register_operand"		  "=A")
	(ashift:QI (match_operand:QI 1 "register_operand" " 0")
		   (const_int 1)))]
  ""
  "asl")

(define_insn "lshrqi3"
  [(set (match_operand:QI 0 "register_operand"		    "=A")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" " 0")
		     (const_int 1)))]
  ""
  "lsr")

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "register_operand"		  "=A")
	(match_operand:QI 1 "register_operand"		  " 0"))]
  ""
  "eor #$ff")

; Jumps & calls.

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "general_operand" "A,r"))]
  ""
  "@
  pha\;lda ah\;pha\;php\;rti
  jmp (%0)")

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0")

(define_insn "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "comparison_operator"
		 [(match_operand:QI 1 "register_operand"	"")
		  (match_operand:QI 2 "immediate_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  "1"
  "cmp foo\;bxx %3")

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use (match_operand 2 "" ""))])])

(define_insn "call_sym"
  [(call (mem:QI (match_operand:HI 0 "" ""))
  	 (match_operand 1 "" ""))
   (use (match_operand 2 "" ""))]
  "GET_CODE (operands[0]) == SYMBOL_REF"
  "jsr %0")

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
        	   (call (match_operand 1 "memory_operand" "")
  			 (match_operand 2 "general_operand" "")))
	      (use (match_operand 3 "" ""))])])

(define_insn "call_value_sym"
  [(set (match_operand 0 "" "")
        (call (mem:QI (match_operand:HI 1 "" ""))
  	      (match_operand 2 "general_operand" "")))
   (use (match_operand 3 "" ""))]
  "GET_CODE (operands[1]) == SYMBOL_REF"
  "jsr %1")

(define_insn "return"
  [(return)]
  ""
  "rts")
