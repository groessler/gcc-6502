; Register constraints (not finalised)
; A -- hard accumulator reg
; x -- hard X reg
; y -- hard Y reg
; h -- all hard regs
; r -- general regs
; S -- stack reg

(define_constants
  [(ACC_REGNUM 0)
   (X_REGNUM 4)
   (Y_REGNUM 8)
   (CC_REGNUM 36)
   (HARDSP_REGNUM 40)
   (TMP0_REGNUM 42)
   (TMP1_REGNUM 43)])

(define_c_enum "unspec" [
  UNSPEC_SBC_OVF	; Overflow flag as set from SBC instruction.
  UNSPEC_NEG_HIBIT	; An eor #$80 setting overflow/negative bits.
  UNSPEC_IOR_CC		; An inclusive-or setting negative/zero bits.
  UNSPEC_ADC_C		; Carry-setting part of add-with-carry.
  UNSPEC_SBC_C		; Carry-setting part of subtract-with-carry.
  UNSPEC_ASL_C		; Carry-setting part of asl.
  UNSPEC_ROR		; 9-bit rotate right through carry.
  UNSPEC_ROL		; 9-bit rotate left through carry.
  UNSPEC_LOADQI
  UNSPEC_STOREQI
])

; There isn't really a sane default length for an instruction. Pick 2 (bytes).
(define_attr "length" ""
  (const_int 2))

(include "constraints.md")
(include "predicates.md")

; HImode/SImode operations.

(define_mode_iterator HISI [HI SI])

(define_expand "mov<mode>"
  [(set (match_operand:HISI 0 "nonimmediate_operand" "")
	(match_operand:HISI 1 "general_operand" ""))]
  ""
{
  int modesize, i;
  bool need_clobber = false;
  rtx seq;
  
  if (!lra_in_progress)
    {
      modesize = GET_MODE_SIZE (<MODE>mode);

      /* We can only load symbol_ref/label_ref to an actual register.  */
      if (!hard_reg_operand (operands[0], <MODE>mode)
	  && sym_const_operand (operands[1], <MODE>mode))
	operands[1] = force_reg (<MODE>mode, operands[1]);

      if (!can_create_pseudo_p ())
	{
	  emit_insn (gen_mov<mode>_noclob (operands[0], operands[1]));
	  DONE;
	}

      if (reload_in_progress && MEM_P (operands[0]))
	{
	  rtx inner = find_replacement (&XEXP (operands[0], 0));
	  if (inner != XEXP (operands[0], 0))
            operands[0] = replace_equiv_address_nv (operands[0], inner);
	}

      if (reload_in_progress && MEM_P (operands[1]))
	{
	  rtx inner = find_replacement (&XEXP (operands[1], 0));
	  if (inner != XEXP (operands[1], 0))
            operands[1] = replace_equiv_address_nv (operands[1], inner);
	}

      start_sequence ();

      for (i = 0; i < modesize; i++)
	{
	  rtx xpart = operand_subword (operands[0], i, 1, <MODE>mode);
	  rtx ypart;

	 /* if (undefined_operand_subword_p (operands[1], i))
            continue;*/

	  ypart = operand_subword (operands[1], i, 1, <MODE>mode);

	  if (ypart == 0 && CONSTANT_P (operands[1]))
            {
	      operands[1] = use_anchored_address (force_const_mem (<MODE>mode,
						  operands[1]));
	      ypart = operand_subword (operands[1], i, 1, <MODE>mode);
	    }
	   else if (operands[1] == 0)
             ypart = operand_subword_force (operands[1], i, <MODE>mode);

	   gcc_assert (xpart && ypart);

	   need_clobber |= (GET_CODE (xpart) == SUBREG);

	   emit_move_insn (xpart, ypart);
	}

      seq = get_insns ();
      end_sequence ();

      if (operands[0] != operands[1]
	  && ! (lra_in_progress || reload_in_progress || reload_completed)
	  && need_clobber)
	emit_clobber (operands[0]);

      emit_insn (seq);

      DONE;
    }
})

; LRA gets very upset if it can't use a single instruction to move caller-saved
; registers out of the way (in split_reg). The following pattern is
; here to appease it, though ideally it wouldn't be necessary.

(define_insn_and_split "mov<mode>_noclob"
  [(set (match_operand:HISI 0 "nonimmediate_operand" "=r,m,r,r")
	(match_operand:HISI 1 "general_operand"       "r,r,m,i"))]
  "lra_in_progress || reload_completed"
  "#"
  ""
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx tmp1 = gen_rtx_REG (QImode, TMP1_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  int i, modesize = GET_MODE_SIZE (<MODE>mode);
  
  emit_move_insn (tmp0, acc);

  if (indirect_mem_operand (operands[1], <MODE>mode))
    {
      rtx addr = XEXP (operands[1], 0);

      emit_move_insn (tmp1, yreg);
      emit_move_insn (yreg, const0_rtx);

      for (i = 0; i < modesize; i++)
        {
	  rtx dstpart = simplify_gen_subreg (QImode, operands[0],
					     <MODE>mode, i);
	  emit_insn (gen_loadqi_indy (acc, yreg, addr));
	  emit_move_insn (dstpart, acc);
	  if (i != modesize - 1)
	    emit_insn (gen_addqi3 (yreg, yreg, const1_rtx));
	}

      emit_move_insn (yreg, tmp1);
    }
  else if (indirect_mem_operand (operands[0], <MODE>mode))
    {
      rtx addr = XEXP (operands[0], 0);

      emit_move_insn (tmp1, yreg);
      emit_move_insn (yreg, const0_rtx);
      
      for (i = 0; i < modesize; i++)
        {
	  rtx srcpart = simplify_gen_subreg (QImode, operands[1],
					     <MODE>mode, i);
	  emit_move_insn (acc, srcpart);
	  emit_insn (gen_storeqi_indy (yreg, addr, acc));
	  if (i != modesize - 1)
	    emit_insn (gen_addqi3 (yreg, yreg, const1_rtx));
	}
      
      emit_move_insn (yreg, tmp1);
    }
  else
    for (i = 0; i < modesize; i++)
      {
	rtx dstpart = simplify_gen_subreg (QImode, operands[0], <MODE>mode, i);
	rtx srcpart = simplify_gen_subreg (QImode, operands[1], <MODE>mode, i);
	emit_move_insn (acc, srcpart);
	emit_move_insn (dstpart, acc);
      }
  
  emit_move_insn (acc, tmp0);
  
  DONE;
})

(define_expand "addhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_operand:HI 1 "register_operand" "")
		 (match_operand:HI 2 "nonmemory_operand" "")))]
  ""
{
  rtx dstpart, op1part, op2part;
  int i, modesize = GET_MODE_SIZE (HImode);
  rtx seq;
  bool need_clobber = false;
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx acc;

  start_sequence ();

  if (!can_create_pseudo_p ())
    {
      acc = gen_rtx_REG (QImode, ACC_REGNUM);
      emit_move_insn (tmp0, acc);
    }
  else
    acc = gen_reg_rtx (QImode);

  emit_insn (gen_clc ());

  for (i = 0; i < modesize; i++)
    {
      dstpart = operand_subword (operands[0], i, 1, HImode);
      op1part = operand_subword (operands[1], i, 1, HImode);
      op2part = operand_subword (operands[2], i, 1, HImode);

      if (op2part == 0 && CONSTANT_P (operands[2]))
        {
	  operands[2] = use_anchored_address (force_const_mem (HImode,
					      operands[2]));
	  op2part = operand_subword (operands[2], i, 1, HImode);
	}
      else if (operands[2] == 0)
	op2part = operand_subword_force (operands[2], i, HImode);

      gcc_assert (dstpart && op1part && op2part);

      need_clobber |= (GET_CODE (dstpart) == SUBREG);

      emit_move_insn (acc, op1part);
      emit_insn (gen_adcqi3_c (acc, acc, op2part));
      emit_move_insn (dstpart, acc);
    }

  if (!can_create_pseudo_p ())
    emit_move_insn (acc, tmp0);

  seq = get_insns ();
  end_sequence ();

  if (operands[0] != operands[1]
      && operands[0] != operands[2]
      && !(lra_in_progress || reload_in_progress || reload_completed)
      && need_clobber)
    emit_clobber (operands[0]);

  emit_insn (seq);

  DONE;
})

(define_insn "addhi3_insn"
  [(set (match_operand:HI 0 "register_operand"          "=r,r")
	(plus:HI (match_operand:HI 1 "register_operand"  "r,r")
		 (match_operand:HI 2 "nonmemory_operand" "r,i")))]
  ""
  "@
  pha\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;pla
  pha\;lda %1\;clc\;adc #<%2\;sta %0\;lda %h1\;adc #>%2\;sta %h0\;pla"
  [(set_attr "length" "15,15")])

(define_expand "sub<mode>3"
  [(set (match_operand:HISI 0 "register_operand" "")
	(minus:HISI (match_operand:HISI 1 "register_operand" "")
		    (match_operand:HISI 2 "reg_or_const_mem_operand" "")))]
  "can_create_pseudo_p ()"
{
  rtx dstpart, op1part, op2part, tmp = gen_reg_rtx (QImode), seq;
  int i, modesize = GET_MODE_SIZE (<MODE>mode);
  bool need_clobber = false;

  start_sequence ();

  emit_insn (gen_sec ());
  
  for (i = 0; i < modesize; i++)
    {
      dstpart = operand_subword (operands[0], i, 1, <MODE>mode);
      op1part = operand_subword (operands[1], i, 1, <MODE>mode);
      op2part = operand_subword (operands[2], i, 1, <MODE>mode);
      
      if (op2part == 0 && CONSTANT_P (operands[2]))
        {
	  operands[2] = use_anchored_address (force_const_mem (<MODE>mode,
					      operands[2]));
	  op2part = operand_subword (operands[2], i, 1, <MODE>mode);
	}
      else if (operands[2] == 0)
        op2part = operand_subword_force (operands[2], i, <MODE>mode);

      gcc_assert (dstpart && op1part && op2part);
      
      need_clobber |= (GET_CODE (dstpart) == SUBREG);
      
      emit_move_insn (tmp, op1part);
      emit_insn (gen_sbcqi3_c (tmp, tmp, op2part));
      emit_move_insn (dstpart, tmp);
    }
  
  seq = get_insns ();
  end_sequence ();
  
  if (operands[0] != operands[1]
      && operands[0] != operands[2]
      && !(lra_in_progress || reload_in_progress || reload_completed)
      && need_clobber)
    emit_clobber (operands[0]);
  
  emit_insn (seq);
  
  DONE;
})

;(define_insn "lshrhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(lshiftrt:HI (match_operand:HI 1 "accumulator_operand"	  "0, 0")
;		     (match_operand:HI 2 "shifthi_amount"	 "Nr,Nc")))
;   (clobber (match_scratch:QI 3 "=X,&jq"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "lsr _ah\;ror a";
;    case 2: return "lsr _ah\;ror a\;lsr _ah\;ror a";
;    case 3: return "lsr _ah\;ror a\;lsr _ah\;ror a\;lsr _ah\;ror a";
;    case 4: return "lsr _ah\;ror a\;lsr _ah\;ror a\;lsr _ah\;ror a\;"
;		   "lsr _ah\;ror a";
;    case 5:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #7\;ld%R3 _ah\;sta _ah\;t%R3a";
;    case 6:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #3\;ld%R3 _ah\;sta _ah\;t%R3a";
;    case 7:
;      return "asl a\;rol _ah\;lda _ah\;stz _ah\;rol _ah";
;    case 8: return "lda _ah\;stz _ah";
;    case 9: return "lda _ah\;ror a\;stz _ah";
;    case 10: return "lda _ah\;ror a\;ror a\;stz _ah";
;    case 11: return "lda _ah\;ror a\;ror a\;ror a\;stz _ah";
;    case 12: return "lda _ah\;ror a\;ror a\;ror a\;ror a\;stz _ah";
;    case 13:
;      return "lda #0\;asl _ah\;rol a\;asl _ah\;rol a\;asl _ah\;rol a\;stz _ah";
;    case 14: return "lda #0\;asl _ah\;rol a\;asl _ah\;rol a\;stz _ah";
;    case 15: return "lda #0\;asl _ah\;rol a\;stz _ah";
;    case 16: return "lda #0\;sta _ah";
;    default: gcc_unreachable ();
;    }
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
;	       (eq (match_dup 2) (const_int 2)) (const_int 6)
;	       (eq (match_dup 2) (const_int 3)) (const_int 9)
;	       (eq (match_dup 2) (const_int 4)) (const_int 12)
;	       (eq (match_dup 2) (const_int 5)) (const_int 18)
;	       (eq (match_dup 2) (const_int 6)) (const_int 15)
;	       (eq (match_dup 2) (const_int 7)) (const_int 9)
;	       (eq (match_dup 2) (const_int 8)) (const_int 4)
;	       (eq (match_dup 2) (const_int 9)) (const_int 5)
;	       (eq (match_dup 2) (const_int 10)) (const_int 6)
;	       (eq (match_dup 2) (const_int 11)) (const_int 7)
;	       (eq (match_dup 2) (const_int 12)) (const_int 8)
;	       (eq (match_dup 2) (const_int 13)) (const_int 13)
;	       (eq (match_dup 2) (const_int 14)) (const_int 10)
;	       (eq (match_dup 2) (const_int 15)) (const_int 7)
;	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
;	      (const_int 0)))])
;
;; This can support more addressing modes!
;
;(define_insn "lshrhi3_addhi"
;  [(set (match_operand:HI 0 "zp_reg_operand"				"=r")
;	(plus:HI (lshiftrt:HI (match_operand:HI 1 "accumulator_operand"  "Ah")
;			      (match_operand:HI 2 "shifthi_rt_byteswap"  "Nc"))
;		 (match_operand:HI 3 "zp_reg_operand"			 "r")))
;   (clobber (match_scratch:QI 4 "=Aq"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 5:
;      return "asl _ah\;rol a\;asl _ah\;rol a\;asl _ah\;rol a\;and #7\;"
;	     "pha\;lda %3\;clc\;adc _ah\;sta %0\;pla\;adc %h3\;sta %h0";
;    case 6:
;      return "asl a\;rol _ah\;php\;asl a\;rol _ah\;pla\;asl a\;adc #0\;and #3\;"
;	     "pha\;lda %3\;clc\;adc _ah\;sta %0\;pla\;adc %h3\;sta %h0";
;    default:
;      gcc_unreachable ();
;    }
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 5)) (const_int 24)
;	       (eq (match_dup 2) (const_int 6)) (const_int 26)]
;	      (const_int 0)))])
;
;(define_insn "ashlhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(ashift:HI (match_operand:HI 1 "accumulator_operand"	 "0, 0")
;		   (match_operand:HI 2 "shifthi_amount"		 "Nl,Nx")))
;   (clobber (match_scratch:QI 3 "=X,&jq"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "asl a\;rol _ah";
;    case 2: return "asl a\;rol _ah\;asl a\;rol _ah";
;    case 3: return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah";
;    case 4: return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;"
;		   "asl a\;rol _ah";
;    case 5:
;      return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;"
;	     "asl a\;rol _ah";
;    case 6:
;      return "ta%R3\;lda _ah\;ror a\;t%R3a\;ror a\;ror _ah\;ror a\;"
;	     "ror _ah\;ta%R3\;lda _ah\;and #$c0\;st%R3 _ah";
;    case 7: return "lsr _ah\;ror a\;sta _ah\;lda #0\;ror a";
;    case 8: return "sta _ah\;lda #0";
;    case 9: return "asl a\;sta _ah\;lda #0";
;    case 10: return "asl a\;asl a\;sta _ah\;lda #0";
;    case 11: return "asl a\;asl a\;asl a\;sta _ah\;lda #0";
;    case 12: return "asl a\;asl a\;asl a\;asl a\;sta _ah\;lda #0";
;    case 13: return "lsr a\;ror a\;ror a\;ror a\;and #$e0\;sta _ah\;lda #0";
;    case 14: return "lsr a\;ror a\;ror a\;and #$c0\;sta _ah\;lda #0";
;    case 15: return "lsr a\;lda #0\;sta _ah\;ror _ah";
;    case 16: return "lda #0\;sta _ah";
;    }
;  return "";
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
;	       (eq (match_dup 2) (const_int 2)) (const_int 6)
;	       (eq (match_dup 2) (const_int 3)) (const_int 9)
;	       (eq (match_dup 2) (const_int 4)) (const_int 12)
;	       (eq (match_dup 2) (const_int 5)) (const_int 15)
;	       (eq (match_dup 2) (const_int 6)) (const_int 18)
;	       (eq (match_dup 2) (const_int 7)) (const_int 8)
;	       (eq (match_dup 2) (const_int 8)) (const_int 4)
;	       (eq (match_dup 2) (const_int 9)) (const_int 5)
;	       (eq (match_dup 2) (const_int 10)) (const_int 6)
;	       (eq (match_dup 2) (const_int 11)) (const_int 7)
;	       (eq (match_dup 2) (const_int 12)) (const_int 8)
;	       (eq (match_dup 2) (const_int 13)) (const_int 10)
;	       (eq (match_dup 2) (const_int 14)) (const_int 9)
;	       (eq (match_dup 2) (const_int 15)) (const_int 7)
;	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
;	      (const_int 0)))])
;
;(define_insn "ashrhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(ashiftrt:HI (match_operand:HI 1 "accumulator_operand"   "0, 0")
;		     (match_operand:HI 2 "shifthi_amount"	 "Na,Nb")))
;   (clobber (match_scratch:QI 3 "=&jq,X"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a";
;    case 2:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a";
;    case 3:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a\;cp%R3 #$80\;ror _ah\;ror a";
;    case 4:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;ror a";
;    case 5:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #7\;ld%R3 _ah\;sta _ah\;and #4\;beq :+\;lda _ah\;ora #$f8\;"
;	     "sta _ah\;:\;t%R3a";
;    case 6:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;and #3\;ld%R3 _ah\;"
;	     "sta _ah\;and #2\;beq :+\;lda _ah\;ora #$fc\;sta _ah\;:\;t%R3a";
;    case 7:
;      return "cmp #$80\;rol _ah\;lda #0\;sbc #0\;eor #$ff\;ld%R3 _ah\;sta _ah\;"
;	     "t%R3a";
;    case 8:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a";
;    case 9:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a";
;    case 10:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a";
;    case 11:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
;    case 12:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;"
;	     "ror a";
;    case 13:
;      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
;	     "asl _ah\;rol a\;asl _ah\;rol a\;st%R3 _ah";
;    case 14:
;      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
;	     "asl _ah\;rol a\;st%R3 _ah";
;    case 15:
;    case 16:
;      return "asl _ah\;lda #0\;sbc #0\;eor #$ff\;sta _ah";
;    }
;  return "";
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 7)
;	       (eq (match_dup 2) (const_int 2)) (const_int 12)
;	       (eq (match_dup 2) (const_int 3)) (const_int 17)
;	       (eq (match_dup 2) (const_int 4)) (const_int 22)
;	       (eq (match_dup 2) (const_int 5)) (const_int 28)
;	       (eq (match_dup 2) (const_int 6)) (const_int 25)
;	       (eq (match_dup 2) (const_int 7)) (const_int 15)
;	       (eq (match_dup 2) (const_int 8)) (const_int 12)
;	       (eq (match_dup 2) (const_int 9)) (const_int 15)
;	       (eq (match_dup 2) (const_int 10)) (const_int 18)
;	       (eq (match_dup 2) (const_int 11)) (const_int 21)
;	       (eq (match_dup 2) (const_int 12)) (const_int 24)
;	       (eq (match_dup 2) (const_int 13)) (const_int 20)
;	       (eq (match_dup 2) (const_int 14)) (const_int 17)
;	       (eq (match_dup 2) (const_int 15)) (const_int 10)
;	       (eq (match_dup 2) (const_int 16)) (const_int 10)]
;	      (const_int 0)))])

(define_expand "cbranchhi4"
  [(parallel
    [(set (pc) (if_then_else
		 (match_operator 0 "m65x_comparison"
	           [(match_operand:HI 1 "register_operand" "")
		    (match_operand:HI 2 "nonmemory_operand" "")])
		 (label_ref (match_operand 3 "" ""))
		 (pc)))
     (clobber (match_scratch:QI 4 ""))])]
  ""
{
  int force_reg_operand;

  switch (GET_CODE (operands[0]))
    {
    case GTU:
    case LEU:
    case GT:
    case LE:
      force_reg_operand = 2;
      break;

    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      force_reg_operand = 1;
      break;

    default:
      gcc_unreachable ();
    }

  if (can_create_pseudo_p () &&
      !register_operand (operands[force_reg_operand], HImode))
    operands[force_reg_operand] = force_reg (HImode,
					     operands[force_reg_operand]);
})

(define_insn_and_split "cbrhi_eq"
  [(set (pc) (if_then_else
	       (eq (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (EQ, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ne"
  [(set (pc) (if_then_else
	       (ne (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (NE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ltu"
  [(set (pc) (if_then_else
	       (ltu (match_operand:HI 0 "zp_reg_operand"        "r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gtu"
  [(set (pc) (if_then_else
	       (gtu (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		    (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_geu"
  [(set (pc) (if_then_else
	       (geu (match_operand:HI 0 "zp_reg_operand"         "r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand"  "r,i"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_leu"
  [(set (pc) (if_then_else
	       (leu (match_operand:HI 1 "zp_reg_or_imm_operand" "r,r,i")
		    (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i,r"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_lt"
  [(set (pc) (if_then_else
	       (lt (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gt"
  [(set (pc) (if_then_else
	       (gt (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ge"
  [(set (pc) (if_then_else
	       (ge (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_le"
  [(set (pc) (if_then_else
	       (le (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "zp_reg_operand" "")
	(sign_extend:SI (match_operand:HI 1 "zp_reg_operand" "")))]
  ""
{
  rtx acc = gen_reg_rtx (QImode);
  rtx cmp, new_label = gen_label_rtx ();
  
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 0),
		  simplify_gen_subreg (QImode, operands[1], HImode, 0));
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 1),
		  simplify_gen_subreg (QImode, operands[1], HImode, 1));

  emit_move_insn (acc, simplify_gen_subreg (QImode, operands[1], HImode, 1));
  emit_insn (gen_iorqi3_n (acc, acc, GEN_INT (0x7f)));
  cmp = gen_rtx_LT (VOIDmode, gen_rtx_REG (CC_Nmode, CC_REGNUM), const0_rtx);
  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
			       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,
				 gen_rtx_LABEL_REF (Pmode, new_label),
				 pc_rtx)));
  emit_move_insn (acc, const0_rtx);
  emit_label (new_label);

  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 2), acc);
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 3), acc);
  
  DONE;
})

(define_expand "neghi2"
  [(set (match_operand:HI 0 "reg_or_const_mem_operand" "")
	(neg:HI (match_operand:HI 1 "reg_or_const_mem_operand" "")))]
  ""
{
  rtx zero = force_reg (HImode, const0_rtx);
  emit_insn (gen_subhi3 (operands[0], zero, operands[1]));
  DONE;
})

; QImode operations.

(define_expand "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
{
  if (can_create_pseudo_p ()
      && MEM_P (operands[0])
      && (MEM_P (operands[1])
	  || (GET_CODE (operands[1]) == CONST_INT
	      && (INTVAL (operands[1]) != 0
		  || !CONSTANT_ADDRESS_P (XEXP (operands[0], 0))))
	  || (!CONSTANT_ADDRESS_P (XEXP (operands[0], 0)) && REG_P (operands[1])
	      && REGNO (operands[1]) != ACC_REGNUM)
	  || !REG_P (operands[1])))
    operands[1] = force_reg (QImode, operands[1]);
})

(define_insn "*movqi_insn"
  [(set (match_operand:QI 0 "nonimmediate_operand"
	      "=hq,Aq,hq,r,hq, r,hq,Uc,<, hq,Aq, m,r,Uc,xq,yq,?hq, ?m,?r,?m")
	(match_operand:QI 1 "general_operand"
		"i,hq,Aq,r, r,hq,Uc,hq,hq, >, m,Aq,z, z,yq,xq, ?m,?hq,?m,?r"))]
  "m65x_valid_mov_operands (QImode, operands)"
  "@
  ld%R0 #%1
  t%R1a
  ta%R0
  #
  ld%R0 %1
  st%R1 %0
  ld%R0 %1
  st%R1 %0
  ph%R1
  pl%R0
  #
  #
  stz %0
  stz %0
  phy\;plx
  phx\;ply
  #
  #
  #
  #"
 [(set_attr "length" "2,1,1,*,2,2,3,3,1,1,*,*,2,3,2,2,*,*,*,*")])

; Handle QImode ZP reg-ZP reg moves post-reload.

(define_split
  [(set (match_operand:QI 0 "zp_reg_operand" "")
	(match_operand:QI 1 "zp_reg_operand" ""))]
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  
  emit_move_insn (tmp0, acc);
  emit_move_insn (acc, operands[1]);
  emit_move_insn (operands[0], acc);
  emit_move_insn (acc, tmp0);
  
  DONE;
})

; ...and try to clean up if a hard reg is available at this point.  (It's not
; clear if this is doing anything.  FIXME?)

(define_peephole2
  [(match_scratch:QI 2 "hq")
   (set (reg:QI TMP0_REGNUM) (reg:QI ACC_REGNUM))
   (set (reg:QI ACC_REGNUM) (match_operand:QI 0 "zp_reg_operand" ""))
   (set (match_operand:QI 1 "zp_reg_operand" "") (reg:QI ACC_REGNUM))
   (set (reg:QI ACC_REGNUM) (reg:QI TMP0_REGNUM))]
  "peep2_regno_dead_p (4, TMP0_REGNUM)"
  [(set (match_dup 2) (match_dup 0))
   (set (match_dup 1) (match_dup 2))])

; Handle QImode indirect-indexed loads.

(define_split
  [(set (match_operand:QI 0 "hard_reg_operand" "")
	(mem:QI (plus:HI (match_operand:HI 1 "zp_reg_operand" "")
			 (match_operand:HI 2 "const_byte_amount" ""))))]
  ""
  [(set (match_dup 0)
	(unspec:QI [(mem:QI (plus:HI (match_dup 1) (match_dup 2)))]
		   UNSPEC_LOADQI))])

(define_split
  [(set (match_operand:QI 0 "hard_reg_operand" "")
	(mem:QI (match_operand:HI 1 "zp_reg_operand" "")))]
  ""
  [(set (match_dup 0)
	(unspec:QI [(mem:QI (plus:HI (match_dup 1) (const_int 0)))]
		   UNSPEC_LOADQI))])

(define_insn_and_split "*loadqi_indy_tmps"
  [(set (match_operand:QI 0 "hard_reg_operand"			  "=Aq,?jq")
	(unspec:QI
	  [(mem:QI (plus:HI (match_operand:HI 1 "zp_reg_operand"    "r,?r")
			    (match_operand:HI 2 "const_byte_amount" "I,?I")))]
	  UNSPEC_LOADQI))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);

  if (REGNO (operands[0]) == ACC_REGNUM)
    {
      emit_move_insn (tmp0, yreg);
      emit_move_insn (yreg, operands[2]);
      emit_insn (gen_loadqi_indy (acc, yreg, operands[1]));
      emit_move_insn (yreg, tmp0);
    }
  else
    {
      rtx tmp1 = gen_rtx_REG (QImode, TMP1_REGNUM);
      
      if (REGNO (operands[0]) != Y_REGNUM)
	emit_move_insn (tmp0, yreg);
      emit_move_insn (tmp1, acc);
      emit_move_insn (yreg, operands[2]);
      emit_insn (gen_loadqi_indy (acc, yreg, operands[1]));
      if (REGNO (operands[0]) != Y_REGNUM)
	emit_move_insn (yreg, tmp0);
      emit_move_insn (operands[0], acc);
      emit_move_insn (acc, tmp1);
    }

  DONE;
})

(define_peephole2
  [(match_scratch:QI 3 "yq")
   (set (match_operand:QI 0 "accumulator_operand" "")
	(unspec:QI [(mem:QI
		      (plus:HI (match_operand:HI 1 "zp_reg_operand" "")
			       (match_operand:HI 2 "const_byte_amount" "")))]
		   UNSPEC_LOADQI))]
  ""
  [(set (match_dup 3) (match_dup 2))
   (set (match_dup 0)
	(mem:QI (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 1))))])

(define_peephole2
  [(match_scratch:QI 3 "yq")
   (match_scratch:QI 4 "Aq")
   (set (match_operand:QI 0 "index_reg_operand" "")
	(unspec:QI [(mem:QI
		      (plus:HI (match_operand:HI 1 "zp_reg_operand" "")
			       (match_operand:HI 2 "const_byte_amount" "")))]
		   UNSPEC_LOADQI))]
  ""
  [(set (match_dup 3) (match_dup 2))
   (set (match_dup 4)
	(mem:QI (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 1))))
   (set (match_dup 0) (match_dup 4))])

(define_insn "loadqi_indy"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(mem:QI (plus:HI
		  (zero_extend:HI (match_operand:QI 1 "y_reg_operand" "yq"))
		  (match_operand:HI 2 "zp_reg_operand" "r"))))]
  ""
  "lda (%2),y"
  [(set_attr "length" "2")])

; Handle QImode indirect-indexed stores.

(define_split
  [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" ""))
	(match_operand:QI 1 "hard_reg_operand" ""))]
  ""
  [(set (mem:QI (plus:HI (match_dup 0) (const_int 0)))
	(match_dup 1))])

(define_insn_and_split "*storeqi_indy_tmps"
  [(set (mem:QI (plus:HI (match_operand:HI 0 "zp_reg_operand" "r,?r")
			 (match_operand:HI 1 "const_byte_amount" "I,?I")))
	(match_operand:QI 2 "hard_reg_operand" "Aq,?jq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  
  if (REGNO (operands[2]) == ACC_REGNUM)
    {
      emit_move_insn (tmp0, yreg);
      emit_move_insn (yreg, operands[1]);
      emit_insn (gen_storeqi_indy (yreg, operands[0], acc));
      emit_move_insn (yreg, tmp0);
    }
  else
    {
      rtx tmp1 = gen_rtx_REG (QImode, TMP1_REGNUM);
      
      emit_move_insn (tmp0, yreg);
      emit_move_insn (tmp1, acc);
      emit_move_insn (acc, operands[2]);
      emit_move_insn (yreg, operands[1]);
      emit_insn (gen_storeqi_indy (yreg, operands[0], acc));
      emit_move_insn (acc, tmp1);
      emit_move_insn (yreg, tmp0);
    }
  
  DONE;
})

(define_peephole2
  [(match_scratch:QI 3 "yq")
   (set (mem:QI (plus:HI (match_operand:HI 0 "zp_reg_operand" "")
			 (match_operand:HI 1 "const_byte_amount" "")))
	(match_operand:QI 2 "accumulator_operand" ""))]
  ""
  [(set (match_dup 3) (match_dup 1))
   (set (mem:QI (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 0)))
	(match_dup 2))])

(define_peephole2
  [(match_scratch:QI 3 "yq")
   (match_scratch:QI 4 "Aq")
   (set (mem:QI (plus:HI (match_operand:HI 0 "zp_reg_operand" "")
			 (match_operand:HI 1 "const_byte_amount" "")))
	(match_operand:QI 2 "index_reg_operand" ""))]
  ""
  [(set (match_dup 4) (match_dup 2))
   (set (match_dup 3) (match_dup 1))
   (set (mem:QI (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 0)))
	(match_dup 4))])

(define_insn "storeqi_indy"
  [(set (mem:QI (plus:HI
		  (zero_extend:HI (match_operand:QI 0 "y_reg_operand" "yq"))
		  (match_operand:HI 1 "zp_reg_operand" "r")))
	(match_operand:QI 2 "accumulator_operand" "Aq"))]
  ""
  "sta (%1),y"
  [(set_attr "length" "2")])

; Opportunistically clean up sequences in movqi pattern which use pha/pla.

(define_peephole2
  [(match_scratch:QI 2 "hq")
   (set (match_operand:QI 0 "zp_reg_or_const_mem_operand" "")
	(match_operand:QI 1 "zp_reg_or_const_mem_operand" ""))]
  ""
  [(parallel [(set (match_dup 0) (match_dup 1))
	      (clobber (match_dup 2))])]
  "")

(define_insn "zp_clob_hardreg_movqi"
  [(set (match_operand:QI 0 "zp_reg_or_const_mem_operand" "=r,Uc, r,Uc")
	(match_operand:QI 1 "zp_reg_or_const_mem_operand"  "r, r,Uc,Uc"))
   (clobber (match_scratch:QI 2 "=hq,hq,hq,hq"))]
  ""
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4,5,5,6")])

; Handle ZP indirect loads/stores.
; We really don't want the following two patterns to be used, but GCC seems to
; get upset without r<-m and m<-r alternatives for QImode moves. With luck, the
; moves to/from tmp0/1 will be removed wherever possible by post-reload passes.

(define_insn_and_split "*zpreg_load_ind"
  [(set (match_operand:QI 0 "zp_reg_operand" "=r")
	(mem:QI (match_operand:HI 1 "zp_reg_operand" "r")))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx tmp1 = gen_rtx_REG (QImode, TMP1_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  
  emit_move_insn (tmp1, yreg);
  emit_move_insn (tmp0, acc);
  emit_move_insn (yreg, const0_rtx);
  emit_insn (gen_loadqi_indy (acc, yreg, operands[1]));
  emit_move_insn (operands[0], acc);
  emit_move_insn (acc, tmp0);
  emit_move_insn (yreg, tmp1);

  DONE;
})

(define_insn_and_split "*zpreg_load_abs"
  [(set (match_operand:QI 0 "zp_reg_operand" "=r")
	(mem:QI (match_operand:HI 1 "immediate_operand" "i")))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  
  emit_move_insn (tmp0, acc);
  emit_insn (gen_rtx_SET (VOIDmode, acc, gen_rtx_MEM (QImode, operands[1])));
  emit_move_insn (operands[0], acc);
  emit_move_insn (acc, tmp0);

  DONE;
})

(define_insn_and_split "*zpreg_store_ind"
  [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" "r"))
	(match_operand:QI 1 "zp_reg_operand" "r"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx tmp1 = gen_rtx_REG (QImode, TMP1_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  
  emit_move_insn (tmp1, yreg);
  emit_move_insn (tmp0, acc);
  emit_move_insn (acc, operands[1]);
  emit_move_insn (yreg, const0_rtx);
  emit_insn (gen_storeqi_indy (yreg, operands[0], acc));
  emit_move_insn (acc, tmp0);
  emit_move_insn (yreg, tmp1);

  DONE;
})

(define_insn_and_split "*zpreg_store_abs"
  [(set (mem:QI (match_operand:HI 0 "immediate_operand" "i"))
	(match_operand:QI 1 "zp_reg_operand" "r"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  
  emit_move_insn (tmp0, acc);
  emit_move_insn (acc, operands[1]);
  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_MEM (QImode, operands[0]), acc));
  emit_move_insn (acc, tmp0);

  DONE;
})

(define_insn "load_sym_lo"
  [(set (match_operand:QI 0 "hard_reg_operand" "=hq")
	(subreg:QI (match_operand:HI 1 "sym_const_operand" "i") 0))]
  ""
  "ld%R0 #<(%1)"
  [(set_attr "length" "2")])

(define_insn "load_sym_hi"
  [(set (match_operand:QI 0 "hard_reg_operand" "=hq")
	(subreg:QI (match_operand:HI 1 "sym_const_operand" "i") 1))]
  ""
  "ld%R0 #>(%1)"
  [(set_attr "length" "2")])

(define_expand "pushqi1"
  [(set (match_operand:QI 0 "hard_sp_operand"  "")
	(match_operand:QI 1 "hard_reg_operand" ""))]
  ""
{})

(define_insn "popqi1"
  [(set (match_operand:QI 0 "hard_reg_operand" "")
	(match_operand:QI 1 "hard_sp_operand"  ""))]
  ""
{})

(define_expand "reload_inoutqi_zp"
  [(parallel [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
		   (match_operand:QI 1 "reload_zpreg_operand" "r"))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=hq"))])]
  ""
{
})

(define_insn "movqi_loadstore_zp"
  [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
	(match_operand:QI 1 "reload_zpreg_operand" "r"))
   (clobber (match_scratch:QI 2 "=hq"))]
  ""
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4")])

(define_insn "addqi3"
  [(set (match_operand:QI 0 "hard_reg_operand"
					     "=Aq,Aq,Aq,Aq,xq,yq,Aq,xq,yq")
	(plus:QI (match_operand:QI 1 "hard_reg_operand"
					      "%0, 0, 0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
					       "r, m, K, I, K, K, M, L, L")))]
  ""
  "@
  clc\;adc %2
  clc\;adc %2
  inc a
  clc\;adc #%2
  inx
  iny
  sec\;sbc #%2
  dex
  dey"
  [(set_attr "length" "3,3,1,3,1,1,3,1,1")])

(define_insn "subqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	    "=Aq,Aq")
	(minus:QI (match_operand:QI 1 "accumulator_operand"   "0, 0")
		  (match_operand:QI 2 "memory_operand"	      "r, m")))]
  ""
  "@
  sec\;sbc %2
  sec\;sbc %2"
  [(set_attr "length" "3")])

(define_insn "clc"
  [(set (reg:CC_C CC_REGNUM) (const_int 0))]
  ""
  "clc"
  [(set_attr "length" "1")])

(define_insn "sec"
  [(set (reg:CC_C CC_REGNUM) (const_int 1))]
  ""
  "sec"
  [(set_attr "length" "1")])

(define_insn "adcqi3_c"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq,Aq")
	(plus:QI
	  (plus:QI (match_operand:QI 1 "accumulator_operand" "0,0")
		   (match_operand:QI 2 "qimode_src_operand" "r,i"))
	  (ne:QI (reg:CC_C CC_REGNUM) (const_int 0))))
   (set (reg:CC_C CC_REGNUM)
	(unspec:CC_C [(match_dup 0) (match_dup 2) (reg:CC_C CC_REGNUM)]
		     UNSPEC_ADC_C))]
  ""
  "@
  adc %2
  adc #%2"
  [(set_attr "length" "2,2")])

(define_insn "sbcqi3_c"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand" "0,0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand" "r,i")
		    (minus:QI (const_int 1)
			      (ne:QI (reg:CC_C CC_REGNUM) (const_int 0))))))
   (set (reg:CC_C CC_REGNUM)
	(unspec:CC_C [(match_dup 0) (match_dup 2) (reg:CC_C CC_REGNUM)]
		     UNSPEC_SBC_C))]
  ""
  "@
  sbc %2
  sbc #%2"
  [(set_attr "length" "2,2")])

(define_insn "sbcqi3_nv"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand" "0,0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand" "r,i")
		    (minus:QI (const_int 1)
			      (ne:QI (reg:CC_C CC_REGNUM) (const_int 0))))))
   (set (reg:CC_NV CC_REGNUM)
	(unspec:CC_NV [(match_dup 0) (match_dup 2) (reg:CC_C CC_REGNUM)]
		      UNSPEC_SBC_OVF))]
  ""
  "@
  sbc %2
  sbc #%2"
  [(set_attr "length" "2,2")])

(define_expand "negqi2"
  [(set (match_operand:QI 0 "register_operand" "")
	(neg:QI (match_operand:QI 1 "register_operand" "")))]
  ""
{
  rtx tmp = gen_reg_rtx (QImode);
  
  emit_insn (gen_xorqi3 (tmp, operands[1], GEN_INT (0xff)));
  emit_insn (gen_sec ());
  emit_insn (gen_adcqi3_c (operands[0], tmp, const0_rtx));
  
  DONE;
})

(define_insn "negate_highbit"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(xor:QI (match_operand:QI 1 "accumulator_operand" "0")
		(const_int 128)))
   (set (reg:CC_NV CC_REGNUM)
	(unspec:CC_NV [(match_dup 0) (reg:CC_NV CC_REGNUM)] UNSPEC_NEG_HIBIT))]
  ""
  "eor #$80\t; negate top bit"
  [(set_attr "length" "2")])

(define_insn "andqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Aq,Aq,Aq")
	(and:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"    "r,Uc, I")))]
  ""
  "@
  and %2
  and %2
  and #%2"
  [(set_attr "length" "2")])

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Aq,Aq,Aq")
	(ior:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"    "r,Uc, I")))]
  ""
  "@
  ora %2
  ora %2
  ora #%2"
  [(set_attr "length" "2")])

(define_insn "iorqi3_n"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Aq,Aq,Aq")
	(ior:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"    "r,Uc, I")))
   (set (reg:CC_N CC_REGNUM)
	(unspec:CC_N [(match_dup 0) (match_dup 2)] UNSPEC_IOR_CC))]
  ""
  "@
  ora %2
  ora %2
  ora #%2"
  [(set_attr "length" "2")])

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Aq,Aq,Aq")
	(xor:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"    "r,Uc, I")))]
  ""
  "@
  eor %2
  eor %2
  eor #%2"
  [(set_attr "length" "2")])

(define_expand "ashlqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "")
	(ashift:QI (match_operand:QI 1 "reg_or_const_mem_operand" "")
		   (match_operand:QI 2 "shiftqi_amount" "")))]
  ""
{
  int i;
  rtx tmp;

  if (!CONST_INT_P (operands[2]))
    FAIL;
  
  switch (INTVAL (operands[2]))
    {
    case 1:
      emit_insn (gen_ashlqi3_insn (operands[0], operands[1], operands[2]));
      break;
    
    case 2:
    case 3:
    case 4:
    case 5:
      tmp = gen_reg_rtx (QImode);
      emit_move_insn (tmp, operands[1]);

      for (i = 0; i < INTVAL (operands[2]); i++)
        emit_insn (gen_ashlqi3_insn (tmp, tmp, const1_rtx));

      emit_move_insn (operands[0], tmp);
      break;
    
    case 6:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rorqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, GEN_INT (0xc0)));
      break;

    case 7:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rorqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, GEN_INT (0x80)));
      break;

    case 8:
      emit_move_insn (operands[0], const0_rtx);
      break;

    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "ashlqi3_insn"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"		"=Aq,r,Uc")
	(ashift:QI (match_operand:QI 1 "reg_or_const_mem_operand" "0,0, 0")
		   (match_operand:QI 2 "const_one_amount"	  "K,K, K")))
   (set (reg:CC_C CC_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2)] UNSPEC_ASL_C))]
  ""
  "@
  asl a
  asl %0
  asl %0"
  [(set_attr "length" "1,2,3")])

(define_insn "m65x_rorqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "=Aq,r,Uc")
	(unspec:QI [(match_operand:QI 1 "reg_or_const_mem_operand" "0,0,0")
		    (reg:CC_C CC_REGNUM)]
		   UNSPEC_ROR))
   (set (reg:CC_C CC_REGNUM)
	(unspec:CC_C [(match_dup 1) (reg:CC_C CC_REGNUM)] UNSPEC_ROR))]
  ""
  "@
  ror a
  ror %0
  ror %0"
  [(set_attr "length" "1,2,3")])

(define_insn "m65x_rolqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "=Aq,r,Uc")
	(unspec:QI [(match_operand:QI 1 "reg_or_const_mem_operand" "0,0,0")
		    (reg:CC_C CC_REGNUM)]
		   UNSPEC_ROL))
   (set (reg:CC_C CC_REGNUM)
	(unspec:CC_C [(match_dup 1) (reg:CC_C CC_REGNUM)] UNSPEC_ROL))]
  ""
  "@
  rol a
  rol %0
  rol %0"
  [(set_attr "length" "1,2,3")])

(define_expand "lshrqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "")
	(lshiftrt:QI (match_operand:QI 1 "reg_or_const_mem_operand" "")
		     (match_operand:QI 2 "shiftqi_amount" "")))]
  ""
{
  int i;
  rtx tmp;

  if (!CONST_INT_P (operands[2]))
    FAIL;
  
  switch (INTVAL (operands[2]))
    {
    case 1:
      emit_insn (gen_lshrqi3_insn (operands[0], operands[1], operands[2]));
      break;
    
    case 2:
    case 3:
    case 4:
    case 5:
      tmp = gen_reg_rtx (QImode);
      emit_move_insn (tmp, operands[1]);

      for (i = 0; i < INTVAL (operands[2]); i++)
        emit_insn (gen_lshrqi3_insn (tmp, tmp, const1_rtx));

      emit_move_insn (operands[0], tmp);
      break;
    
    case 6:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rolqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, GEN_INT (0x03)));
      break;

    case 7:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rolqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, GEN_INT (0x01)));
      break;

    case 8:
      emit_move_insn (operands[0], const0_rtx);
      break;

    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "lshrqi3_insn"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "=Aq,r,Uc")
	(lshiftrt:QI
	  (match_operand:QI 1 "reg_or_const_mem_operand" "0,0, 0")
	  (match_operand:QI 2 "const_one_amount"	 "K,K, K")))]
  ""
  "@
  lsr a
  lsr %0
  lsr %0"
  [(set_attr "length" "1,2,3")])

(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	       "=Aq")
	(ashiftrt:QI (match_operand:QI 1 "accumulator_operand"  "0")
		     (match_operand:QI 2 "shiftqi_amount"       "NB")))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "cmp #$80\;ror a";
    case 2: return "cmp #$80\;ror a\;cmp #$80\;ror a";
    case 3: return "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
    case 4: return "lsr a\;lsr a\;lsr a\;lsr a\;cmp #8\;bcc :+\;ora #$f0\;:";
    case 5: return "lsr a\;lsr a\;lsr a\;lsr a\;lsr a\;cmp #4\;bcc :+\;"
		   "ora #$f8\;:";
    case 6: return "rol a\;rol a\;rol a\;and #3\;cmp #2\;bcc :+\;ora #$fc\;:";
    case 7:
    case 8: return "ora #$7f\;bmi :+\;lda #0\;:";
    default: gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
	       (eq (match_dup 2) (const_int 2)) (const_int 6)
	       (eq (match_dup 2) (const_int 3)) (const_int 9)
	       (eq (match_dup 2) (const_int 4)) (const_int 10)
	       (eq (match_dup 2) (const_int 5)) (const_int 11)
	       (eq (match_dup 2) (const_int 6)) (const_int 11)
	       (eq (match_dup 2) (const_int 7)) (const_int 6)
	       (eq (match_dup 2) (const_int 8)) (const_int 6)]
	      (const_int 0)))])

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(match_operand:QI 1 "accumulator_operand"   "0"))]
  ""
  "eor #$ff"
  [(set_attr "length" "2")])

; Comparisons.

(define_mode_iterator CMPQI [CC CC_C])

(define_insn "compareqi_<mode>"
  [(set (reg:CMPQI CC_REGNUM)
	(compare:CMPQI (match_operand:QI 0 "hard_reg_operand"    "hq,hq,hq")
		       (match_operand:QI 1 "compareqi_src_operand"
								  "r, i,Uc")))]
  ""
  "@
  %C0 %1
  %C0 #%1
  %C0 %1"
  [(set_attr "length" "2,2,3")])

; Jumps & calls.

(define_mode_iterator CBRQI [CC CC_NV CC_N])
(define_mode_attr signedness [(CC "uns") (CC_NV "sgn") (CC_N "nonly")])

(define_insn "condbranchqi_<mode>"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_<signedness>_comparison"
			[(reg:CBRQI CC_REGNUM) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (<MODE>mode, operands[0], operands[1],
		     get_attr_length (insn) > 2);
  return "";
}
  [(set (attr "length")
	(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -110))
			   (lt (minus (match_dup 1) (pc)) (const_int 110)))
		      (const_int 2)
		      (const_int 5)))])

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "zp_reg_operand" "r"))]
  ""
  "jmp (%0)"
  [(set_attr "length" "2")])

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0"
  [(set_attr "length" "3")])

(define_expand "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "m65x_comparison"
		 [(match_operand:QI 1 "register_operand"	"")
		  (match_operand:QI 2 "nonmemory_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  ""
{
  switch (GET_CODE (operands[0]))
    {
    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      m65x_emit_qimode_comparison (GET_CODE (operands[0]), operands[1],
				   operands[2], operands[3]);
      break;

    case LEU:
      m65x_emit_qimode_comparison (GEU, operands[2], operands[1], operands[3]);
      break;

    case GTU:
      m65x_emit_qimode_comparison (LTU, operands[2], operands[1], operands[3]);
      break;

    case LE:
      m65x_emit_qimode_comparison (GE, operands[2], operands[1], operands[3]);
      break;

    case GT:
      m65x_emit_qimode_comparison (LT, operands[2], operands[1], operands[3]);
      break;
    
    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use (const_int 0))])])

(define_insn "call_sym"
  [(call (mem:QI (match_operand:HI 0 "" ""))
  	 (match_operand 1 "" ""))
   (use (const_int 0))]
  "GET_CODE (operands[0]) == SYMBOL_REF"
  "jsr %0"
  [(set_attr "length" "3")])

(define_insn "call_indirect"
  [(call (mem:QI (match_operand:HI 0 "register_operand" "r"))
	 (match_operand 1 "" ""))
   (use (const_int 0))]
  ""
  "lda #<:+-1\;pha\;lda #>:+-1\;pha\;jmp (%0)\;:"
  [(set_attr "length" "9")])

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
        	   (call (match_operand 1 "memory_operand" "")
  			 (match_operand 2 "general_operand" "")))
	      (use (const_int 0))])])

(define_insn "call_value_sym"
  [(set (match_operand 0 "" "")
        (call (mem:QI (match_operand:HI 1 "" ""))
  	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  "GET_CODE (operands[1]) == SYMBOL_REF"
  "jsr %1"
  [(set_attr "length" "3")])

(define_insn "call_indirect_sym"
  [(set (match_operand 0 "" "")
	(call (mem:QI (match_operand:HI 1 "zp_reg_operand" "r"))
	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  ""
  "lda #<:+-1\;pha\;lda #>:+-1\;pha\;jmp (%0)\;:"
  [(set_attr "length" "9")])

(define_insn "m65x_return"
  [(return)]
  ""
  "rts"
  [(set_attr "length" "1")])

(define_expand "prologue"
  [(pc)]
  ""
{
  m65x_expand_prologue ();
  DONE;
})

(define_expand "epilogue"
  [(pc)]
  ""
{
  m65x_expand_epilogue ();
  DONE;
})
