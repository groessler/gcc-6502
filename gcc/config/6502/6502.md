(define_attr "arch"
  "any,n02,n02x,nmos,wc02,wsc02,huc,cmos,phx,no_phx"
  (const_string "any"))

(define_attr "arch_enabled" "no,yes"
  (cond [(eq_attr "arch" "any")
	 (const_string "yes")
	 
	 (and (eq_attr "arch" "n02")
	      (match_test "TARGET_6502"))
	 (const_string "yes")

	 (and (eq_attr "arch" "n02x")
	      (match_test "TARGET_6502X"))
	 (const_string "yes")

	 (and (eq_attr "arch" "nmos")
	      (match_test "TARGET_NMOS"))
	 (const_string "yes")

	 (and (eq_attr "arch" "wc02")
	      (match_test "TARGET_65C02"))
	 (const_string "yes")

	 (and (eq_attr "arch" "wsc02")
	      (match_test "TARGET_65SC02"))
	 (const_string "yes")

	 (and (eq_attr "arch" "huc")
	      (match_test "TARGET_HUC6280"))
	 (const_string "yes")

	 (and (eq_attr "arch" "cmos")
	      (match_test "TARGET_CMOS"))
	 (const_string "yes")

	 (and (eq_attr "arch" "phx")
	      (match_test "TARGET_PHX"))
	 (const_string "yes")

	 (and (eq_attr "arch" "no_phx")
	      (match_test "!TARGET_PHX"))
	 (const_string "yes")]
	
	(const_string "no")))

(define_attr "enabled" "no,yes"
  (cond [(eq_attr "arch_enabled" "no")
	 (const_string "no")]
	(const_string "yes")))

(define_constants
  [(ACC_REGNUM 0)
   (X_REGNUM 4)
   (Y_REGNUM 8)
   (NZ_REGNUM 36)
   (CARRY_REGNUM 40)
   (OVERFLOW_REGNUM 44)
   (HARDSP_REGNUM 48)
   (TMP0_REGNUM 50)
   (TMP1_REGNUM 51)])

(define_c_enum "unspec" [
  UNSPEC_SBC_NZ		; NZ flag as set from SBC instruction.
  UNSPEC_SBC_OVF	; Overflow flag as set from SBC instruction.
  UNSPEC_NEG_HIBIT	; An eor #$80 setting overflow/negative bits.
  UNSPEC_IOR_CC		; An inclusive-or setting negative/zero bits.
  UNSPEC_ADC_C		; Carry-setting part of add-with-carry.
  UNSPEC_SBC_C		; Carry-setting part of subtract-with-carry.
  UNSPEC_ASL_C		; Carry-setting part of asl.
  UNSPEC_ROR		; 9-bit rotate right through carry.
  UNSPEC_ROL		; 9-bit rotate left through carry.
  UNSPEC_LOADQI
  UNSPEC_STOREQI
  UNSPEC_MOVZP
  UNSPEC_MOVZP_CLOB
  UNSPEC_FLAGS
  UNSPEC_FLAGS_NZ
  UNSPEC_FLAGS_C
  UNSPEC_FLAGS_V
  UNSPEC_XIND		; Indexed indirect addressing.
])

; There isn't really a sane default length for an instruction. Pick 2 (bytes).
(define_attr "length" ""
  (const_int 2))

(include "constraints.md")
(include "predicates.md")

; HImode/SImode operations.

(define_mode_iterator HISI [HI SI])

(define_expand "mov<mode>"
  [(set (match_operand:HISI 0 "nonimmediate_operand" "")
	(match_operand:HISI 1 "general_operand" ""))]
  ""
{
  int modesize, i;
  bool need_clobber = false;
  rtx seq;
  
  if (!lra_in_progress && can_create_pseudo_p ())
    {
      rtx dest = operands[0];
      modesize = GET_MODE_SIZE (<MODE>mode);

      /* If address moves get split up into separate byte register moves, we
         never get a chance to use some useful addressing modes.  So, if we
	 see a pointer, don't split it up yet.  */

#if 0
      if ((REG_P (operands[0]) && REG_POINTER (operands[0]))
          || (GET_CODE (operands[0]) == SUBREG
	      && REG_POINTER (SUBREG_REG (operands[0])))
	  || (REG_P (operands[1]) && REG_POINTER (operands[1]))
	  || (GET_CODE (operands[1]) == SUBREG
	      && REG_POINTER (SUBREG_REG (operands[1])))
	  || GET_CODE (operands[1]) == SYMBOL_REF
	  || GET_CODE (operands[1]) == LABEL_REF)
	{
	  emit_insn (gen_mov<mode>_scratch (operands[0], operands[1]));
	  DONE;
	}
#endif

      /* We can only load symbol_ref/label_ref to an actual register.  */
      if (!hard_reg_operand (operands[0], <MODE>mode)
	  && sym_const_operand (operands[1], <MODE>mode))
	operands[1] = force_reg (<MODE>mode, operands[1]);

      /* The below code is adapted from expr.c:emit_move_multi_word.  */

      if (reload_in_progress && MEM_P (operands[0]))
	{
	  rtx inner = find_replacement (&XEXP (operands[0], 0));
	  if (inner != XEXP (operands[0], 0))
            operands[0] = replace_equiv_address_nv (operands[0], inner);
	}

      if (reload_in_progress && MEM_P (operands[1]))
	{
	  rtx inner = find_replacement (&XEXP (operands[1], 0));
	  if (inner != XEXP (operands[1], 0))
            operands[1] = replace_equiv_address_nv (operands[1], inner);
	}

      if (operands[0] != operands[1]
	  && REG_P (operands[0])
	  && reg_overlap_mentioned_p (operands[0], operands[1]))
	dest = gen_reg_rtx (HImode);

      start_sequence ();

      for (i = 0; i < modesize; i++)
	{
	  rtx xpart = operand_subword (dest, i, 1, <MODE>mode);
	  rtx ypart;

	 /* if (undefined_operand_subword_p (operands[1], i))
            continue;*/

	  ypart = operand_subword (operands[1], i, 1, <MODE>mode);

	  if (ypart == 0 && CONSTANT_P (operands[1]))
            {
	      operands[1] = use_anchored_address (force_const_mem (<MODE>mode,
						  operands[1]));
	      ypart = operand_subword (operands[1], i, 1, <MODE>mode);
	    }
	  else if (ypart == 0)
            ypart = operand_subword_force (operands[1], i, <MODE>mode);

	  gcc_assert (xpart && ypart);

	  need_clobber |= (GET_CODE (xpart) == SUBREG);

	  emit_move_insn (xpart, ypart);
	}

      seq = get_insns ();
      end_sequence ();

      if (dest != operands[1]
	  && ! (lra_in_progress || reload_in_progress || reload_completed)
	  && need_clobber)
	emit_clobber (operands[0]);

      emit_insn (seq);

      if (dest != operands[0])
        emit_move_insn (operands[0], dest);

      DONE;
    }
})

; LRA gets very upset if it can't use a single instruction to move caller-saved
; registers out of the way (in split_reg). The following pattern is
; here to appease it, though ideally it wouldn't be necessary.

(define_insn_and_split "mov<mode>_noclob"
  [(set (match_operand:HISI 0 "nonimmediate_operand" "=&r,m,r,r")
	(match_operand:HISI 1 "general_operand"        "r,r,m,i"))]
  "(register_operand (operands[0], <MODE>mode)
    || register_operand (operands[1], <MODE>mode))
   && (lra_in_progress || reload_completed)"
  "#"
  "&& reload_completed"
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  int i, modesize = GET_MODE_SIZE (<MODE>mode);

  emit_insn (m65x_push (QImode, acc));

  if (indirect_mem_operand (operands[1], <MODE>mode)
      || indirect_offset_mem_operand (operands[1], <MODE>mode))
    {
      rtx addr = XEXP (operands[1], 0);
      HOST_WIDE_INT offset;
      rtx base;

      if (REG_P (addr))
        {
	  base = addr;
	  offset = 0;
	}
      else if (GET_CODE (addr) == PLUS)
        {
	  base = XEXP (addr, 0);
	  offset = INTVAL (XEXP (addr, 1));
	}
      else
        gcc_unreachable ();

      if (TARGET_PHX)
	emit_insn (m65x_push (QImode, yreg));
      else
        {
	  emit_move_insn (acc, yreg);
	  emit_insn (m65x_push (QImode, acc));
	}
      emit_move_insn (yreg, gen_int_mode (offset, QImode));

      for (i = 0; i < modesize; i++)
        {
	  rtx dstpart = simplify_gen_subreg (QImode, operands[0],
					     <MODE>mode, i);
	  emit_insn (gen_loadqi_indy (acc, yreg, base));
	  emit_move_insn (dstpart, acc);
	  if (i != modesize - 1)
	    emit_insn (gen_incdecqi3 (yreg, yreg, const1_rtx));
	}

      if (TARGET_PHX)
	emit_insn (m65x_pop (QImode, yreg));
      else
        {
	  emit_insn (m65x_pop (QImode, acc));
	  emit_move_insn (yreg, acc);
	}
    }
  else if (indirect_mem_operand (operands[0], <MODE>mode)
	   || indirect_offset_mem_operand (operands[0], <MODE>mode))
    {
      rtx addr = XEXP (operands[0], 0);
      HOST_WIDE_INT offset;
      rtx base;

      if (REG_P (addr))
        {
	  base = addr;
	  offset = 0;
	}
      else if (GET_CODE (addr) == PLUS)
        {
	  base = XEXP (addr, 0);
	  offset = INTVAL (XEXP (addr, 1));
	}
      else
        gcc_unreachable ();

      if (TARGET_PHX)
	emit_insn (m65x_push (QImode, yreg));
      else
        {
	  emit_move_insn (acc, yreg);
	  emit_insn (m65x_push (QImode, acc));
	}

      emit_move_insn (yreg, gen_int_mode (offset, QImode));
      
      for (i = 0; i < modesize; i++)
        {
	  rtx srcpart = simplify_gen_subreg (QImode, operands[1],
					     <MODE>mode, i);
	  emit_move_insn (acc, srcpart);
	  emit_insn (gen_storeqi_indy (yreg, base, acc));
	  if (i != modesize - 1)
	    emit_insn (gen_incdecqi3 (yreg, yreg, const1_rtx));
	}
      
      if (TARGET_PHX)
	emit_insn (m65x_pop (QImode, yreg));
      else
        {
	  emit_insn (m65x_pop (QImode, acc));
	  emit_move_insn (yreg, acc);
	}
    }
  else
    {
      bool backwards = false;

      if (REG_P (operands[0]) && operands[0] != operands[1]
	  && reg_overlap_mentioned_p (operands[0], operands[1]))
	{
	  gcc_assert (REG_P (operands[0])
		      && IS_ZP_REGNUM (REGNO (operands[0])));
	  gcc_assert (REG_P (operands[1])
		      && IS_ZP_REGNUM (REGNO (operands[1])));
	  if (REGNO (operands[0]) < REGNO (operands[1]))
	    backwards = true;
	}

      if (backwards)
	for (i = modesize - 1; i >= 0; i--)
	  {
	    rtx dstpart = simplify_gen_subreg (QImode, operands[0],
					       <MODE>mode, i);
	    rtx srcpart = simplify_gen_subreg (QImode, operands[1],
					       <MODE>mode, i);
	    emit_move_insn (acc, srcpart);
	    emit_move_insn (dstpart, acc);
	  }
      else
	for (i = 0; i < modesize; i++)
	  {
	    rtx dstpart = simplify_gen_subreg (QImode, operands[0],
					       <MODE>mode, i);
	    rtx srcpart = simplify_gen_subreg (QImode, operands[1],
					       <MODE>mode, i);
	    emit_move_insn (acc, srcpart);
	    emit_move_insn (dstpart, acc);
	  }
    }
  
  emit_insn (m65x_pop (QImode, acc));
  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));
  
  DONE;
})

; It's bad to split addresses early (?).

(define_insn "mov<mode>_scratch"
  [(set (match_operand:HISI 0 "nonimmediate_operand" "=r,r, r, r, r,Uo,Ur,Uc")
	(match_operand:HISI 1 "general_operand"       "r,i,Uo,Ur,Uc, r, r, r"))
   (clobber (match_scratch:QI 2 "=hq,hq,Aq,Aq,hq,Aq,Aq,hq"))
   (clobber (match_scratch:QI 3  "=X, X,yq,yq, X,yq,yq, X"))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "0"
{
  switch (which_alternative)
    {
    case 0: return "ld%R2 %1\;st%R2 %0\;ld%R2 %h1\;st%R2 %h0";
    case 1: return "ld%R2 #%L1\;st%R2 %0\;ld%R2 #%H1\;st%R2 %h0";
    case 2: return ";loadhi %0,xxx";
    case 3: return ";loadhi %0,%1";
    case 4: return ";loadhi %0,%1";
    case 5: return ";storehi xxx,%1";
    case 6: return ";storehi %0,%1";
    case 7: return ";storehi %0,%1";
    default: gcc_unreachable ();
    }
}
  [(set_attr "length" "8,8,16,16,16,16,16,16")])

(define_expand "addhi3"
  [(parallel [(set (match_operand:HI 0 "nonimmediate_operand" "")
		   (plus:HI (match_operand:HI 1 "general_operand" "")
			    (match_operand:HI 2 "general_operand" "")))
	      (clobber (reg:CC_C CARRY_REGNUM))
	      (clobber (reg:CC_NZ NZ_REGNUM))
	      (clobber (reg:CC_V OVERFLOW_REGNUM))])]
  ""
{
  rtx dstpart, op1part, op2part;
  int i, modesize = GET_MODE_SIZE (HImode);
  rtx seq;
  bool need_clobber = false;
  rtx acc;
  rtx dest = operands[0];

#if 0
  /* Eagerly splitting up adds used to calculate addresses is
     counterproductive, because it inhibits middle-end passes which deal with
     addressing modes, etc.  FIXME.  */
  if ((REG_P (operands[1]) && REG_POINTER (operands[1]))
      || (REG_P (operands[2]) && REG_POINTER (operands[2]))
      || GET_CODE (operands[1]) == SYMBOL_REF
      || GET_CODE (operands[2]) == SYMBOL_REF)
    {
      emit_insn (gen_addhi3_noclob (operands[0], operands[1], operands[2]));
      DONE;
    }
#endif

  if (can_create_pseudo_p ())
    {
      /* References to virtual_<foo> can turn into adds/subs themselves.  */
      for (i = 1; i <= 2; i++)
	if (reg_mentioned_p (virtual_incoming_args_rtx, operands[i]))
	  operands[i] = copy_to_mode_reg (HImode, operands[i]);

      start_sequence ();

      acc = gen_reg_rtx (QImode);

      if (REG_P (operands[0])
	  && ((operands[0] != operands[1]
	       && reg_overlap_mentioned_p (operands[0], operands[1]))
	      || (operands[0] != operands[2]
		  && reg_overlap_mentioned_p (operands[0], operands[2]))))
	dest = gen_reg_rtx (HImode);

      emit_insn (gen_clc ());

      for (i = 0; i < modesize; i++)
	{
	  dstpart = operand_subword (dest, i, 1, HImode);
	  op1part = operand_subword (operands[1], i, 1, HImode);
	  op2part = operand_subword (operands[2], i, 1, HImode);

	  if (op2part == 0 && CONSTANT_P (operands[2]))
            {
	      operands[2] = use_anchored_address (force_const_mem (HImode,
						  operands[2]));
	      op2part = operand_subword (operands[2], i, 1, HImode);
	    }
	  else if (op2part == 0)
	    op2part = operand_subword_force (operands[2], i, HImode);

	  gcc_assert (dstpart && op1part && op2part);

	  need_clobber |= (GET_CODE (dstpart) == SUBREG);

	  emit_move_insn (acc, op1part);
	  emit_insn (gen_adcqi3_c (acc, acc, op2part));
	  emit_move_insn (dstpart, acc);
	}

      if (dest != operands[0])
	emit_move_insn (operands[0], dest);

      seq = get_insns ();
      end_sequence ();

      if (operands[0] != operands[1]
	  && operands[0] != operands[2]
	  && !(lra_in_progress || reload_in_progress || reload_completed)
	  && need_clobber)
	emit_clobber (operands[0]);

      emit_insn (seq);

      DONE;
    }
})

; An add that is generated post-reload (not by LRA), e.g. during prologue
; emission. Cannot clobber accumulator. (Prologue insns also can't be split --
; maybe splitting should be done "long hand".)

(define_insn "addhi3_noclobacc"
  [(set (match_operand:HI 0 "register_operand"          "=&r,r")
	(plus:HI (match_operand:HI 1 "register_operand"   "r,r")
		 (match_operand:HI 2 "nonmemory_operand"  "r,i")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  "reload_completed"
  "@
  sta _tmp0\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;lda _tmp0
  sta _tmp0\;lda %1\;clc\;adc #%L2\;sta %0\;lda %h1\;adc #%H2\;sta %h0\;lda _tmp0"
  [(set_attr "length" "15,15")])

;(define_insn "addhi3_clobacc"
;  [(set (match_operand:HI 0 "register_operand"          "=&r,r")
;	(plus:HI (match_operand:HI 1 "register_operand"   "r,r")
;		 (match_operand:HI 2 "nonmemory_operand"  "r,i")))
;   (clobber (match_operand:QI 3 "accumulator_operand"   "=Aq,Aq"))
;   (clobber (reg:CC_C CARRY_REGNUM))
;   (clobber (reg:CC_NZ NZ_REGNUM))
;   (clobber (reg:CC_V OVERFLOW_REGNUM))]
;  ""
;  "@
;  lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0
;  lda %1\;clc\;adc #%L2\;sta %0\;lda %h1\;adc #%H2\;sta %h0"
;  [(set_attr "length" "13,13")])

; This pattern is used primarily during LRA.  This version really can't clobber
; anything, including the flags register.  This pattern is generated directly,
; it doesn't come via the addhi3 expander.

(define_insn "addhi3_noclob"
  [(set (match_operand:HI 0 "register_operand"		 "=&r,r")
	(plus:HI (match_operand:HI 1 "register_operand"   "%r,r")
		 (match_operand:HI 2 "nonmemory_operand"   "r,i")))]
  ""
  "@
  php\;sta _tmp0\;lda %1\;clc\;adc %2\;sta %0\;lda %h1\;adc %h2\;sta %h0\;lda _tmp0\;plp
  php\;sta _tmp0\;lda %1\;clc\;adc #%L2\;sta %0\;lda %h1\;adc #%H2\;sta %h0\;lda _tmp0\;plp"
  [(set_attr "length" "19,19")])

;{
;  /*rtx push_rtx = gen_rtx_MEM (CCmode,
;		  gen_rtx_POST_DEC (Pmode,
;				    gen_rtx_REG (Pmode, HARDSP_REGNUM)));
;  rtx pop_rtx = gen_rtx_MEM (CCmode,
;		  gen_rtx_PRE_INC (Pmode,
;				   gen_rtx_REG (Pmode, HARDSP_REGNUM)));
;  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
;  rtx tmp0 = gen_rtx_REG (QImode, TMP0_REGNUM);
;
;  emit_insn (gen_pushflags (push_rtx));
;  emit_insn (gen_addhi3_noclobacc (operands[0], operands[1], operands[2]));
;  emit_insn (gen_popflags (pop_rtx));
;  
;  DONE;*/
;  
;  return "php\;"
;	 "lda %1\;"
;	 "clc\;"
;	 "adc %2\;"
;	 "sta %0\;"
;	 "lda %h1\;"
;	 "adc %h2
;})

; Try to remove the flag-preserving code from addhi3_noclob.

;(define_peephole2
;  [(set (match_operand:CC 0 "hard_sp_operand" "")
;	(unspec_volatile [(reg:CC_NZ NZ_REGNUM)
;			  (reg:CC_C CARRY_REGNUM)
;			  (reg:CC_V OVERFLOW_REGNUM)] UNSPEC_FLAGS))
;   (parallel [(set (match_operand:HI 1 "register_operand" "")
;	   (plus:HI (match_operand:HI 2 "register_operand" "")
;			    (match_operand:HI 3 "nonmemory_operand" "")))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])
;   (parallel [(set (reg:CC_NZ NZ_REGNUM)
;		   (unspec_volatile [(match_operand:CC 4 "hard_sp_operand" "")]
;				    UNSPEC_FLAGS_NZ))
;	      (set (reg:CC_C CARRY_REGNUM)
;		   (unspec_volatile [(match_dup 4)] UNSPEC_FLAGS_C))
;	      (set (reg:CC_V OVERFLOW_REGNUM)
;		   (unspec_volatile [(match_dup 4)] UNSPEC_FLAGS_V))])]
;  "peep2_regno_dead_p (3, NZ_REGNUM)
;   && peep2_regno_dead_p (3, CARRY_REGNUM)
;   && peep2_regno_dead_p (3, OVERFLOW_REGNUM)"
;  [(parallel [(set (match_dup 1) (plus:HI (match_dup 2) (match_dup 3)))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])]
;)

; Try to remove flag-preserving code from addhi3_clobacc.

;(define_peephole2
;  [(set (match_operand:CC 0 "hard_sp_operand" "")
;	(unspec_volatile [(reg:CC_NZ NZ_REGNUM)
;			  (reg:CC_C CARRY_REGNUM)
;			  (reg:CC_V OVERFLOW_REGNUM)] UNSPEC_FLAGS))
;   (parallel [(set (match_operand:HI 1 "register_operand" "")
;		   (plus:HI (match_operand:HI 2 "register_operand" "")
;			    (match_operand:HI 3 "nonmemory_operand" "")))
;	      (clobber (match_operand:QI 4 "accumulator_operand" ""))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])
;   (parallel [(set (reg:CC_NZ NZ_REGNUM)
;		   (unspec_volatile [(match_operand:CC 5 "hard_sp_operand" "")]
;				    UNSPEC_FLAGS_NZ))
;	      (set (reg:CC_C CARRY_REGNUM)
;		   (unspec_volatile [(match_dup 5)] UNSPEC_FLAGS_C))
;	      (set (reg:CC_V OVERFLOW_REGNUM)
;		   (unspec_volatile [(match_dup 5)] UNSPEC_FLAGS_V))])]
;  "peep2_regno_dead_p (3, NZ_REGNUM)
;   && peep2_regno_dead_p (3, CARRY_REGNUM)
;   && peep2_regno_dead_p (3, OVERFLOW_REGNUM)"
;  [(parallel [(set (match_dup 1) (plus:HI (match_dup 2) (match_dup 3)))
;	      (clobber (match_dup 4))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])]
;)

; Try to turn addhi3_noclobacc into addhi3_clobacc.

;(define_peephole2
;  [(match_scratch:QI 3 "Aq")
;   (parallel [(set (match_operand:HI 0 "register_operand" "")
;		   (plus:HI (match_operand:HI 1 "register_operand" "")
;			    (match_operand:HI 2 "nonmemory_operand" "")))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])]
;  ""
;  [(parallel [(set (match_dup 0) (plus:HI (match_dup 1) (match_dup 2)))
;	      (clobber (match_dup 3))
;	      (clobber (reg:CC_C CARRY_REGNUM))
;	      (clobber (reg:CC_NZ NZ_REGNUM))
;	      (clobber (reg:CC_V OVERFLOW_REGNUM))])]
;)

(define_expand "sub<mode>3"
  [(set (match_operand:HISI 0 "register_operand" "")
	(minus:HISI (match_operand:HISI 1 "register_operand" "")
		    (match_operand:HISI 2 "reg_or_const_mem_operand" "")))]
  "can_create_pseudo_p ()"
{
  rtx dstpart, op1part, op2part, tmp = gen_reg_rtx (QImode), seq;
  int i, modesize = GET_MODE_SIZE (<MODE>mode);
  bool need_clobber = false;

  start_sequence ();

  emit_insn (gen_sec ());
  
  for (i = 0; i < modesize; i++)
    {
      dstpart = operand_subword (operands[0], i, 1, <MODE>mode);
      op1part = operand_subword (operands[1], i, 1, <MODE>mode);
      op2part = operand_subword (operands[2], i, 1, <MODE>mode);
      
      if (op2part == 0 && CONSTANT_P (operands[2]))
        {
	  operands[2] = use_anchored_address (force_const_mem (<MODE>mode,
					      operands[2]));
	  op2part = operand_subword (operands[2], i, 1, <MODE>mode);
	}
      else if (operands[2] == 0)
        op2part = operand_subword_force (operands[2], i, <MODE>mode);

      gcc_assert (dstpart && op1part && op2part);
      
      need_clobber |= (GET_CODE (dstpart) == SUBREG);
      
      emit_move_insn (tmp, op1part);
      emit_insn (gen_sbcqi3_c (tmp, tmp, op2part));
      emit_move_insn (dstpart, tmp);
    }
  
  seq = get_insns ();
  end_sequence ();
  
  if (operands[0] != operands[1]
      && operands[0] != operands[2]
      && !(lra_in_progress || reload_in_progress || reload_completed)
      && need_clobber)
    emit_clobber (operands[0]);
  
  emit_insn (seq);
  
  DONE;
})

;(define_insn "lshrhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(lshiftrt:HI (match_operand:HI 1 "accumulator_operand"	  "0, 0")
;		     (match_operand:HI 2 "shifthi_amount"	 "Nr,Nc")))
;   (clobber (match_scratch:QI 3 "=X,&jq"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "lsr _ah\;ror a";
;    case 2: return "lsr _ah\;ror a\;lsr _ah\;ror a";
;    case 3: return "lsr _ah\;ror a\;lsr _ah\;ror a\;lsr _ah\;ror a";
;    case 4: return "lsr _ah\;ror a\;lsr _ah\;ror a\;lsr _ah\;ror a\;"
;		   "lsr _ah\;ror a";
;    case 5:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #7\;ld%R3 _ah\;sta _ah\;t%R3a";
;    case 6:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #3\;ld%R3 _ah\;sta _ah\;t%R3a";
;    case 7:
;      return "asl a\;rol _ah\;lda _ah\;stz _ah\;rol _ah";
;    case 8: return "lda _ah\;stz _ah";
;    case 9: return "lda _ah\;ror a\;stz _ah";
;    case 10: return "lda _ah\;ror a\;ror a\;stz _ah";
;    case 11: return "lda _ah\;ror a\;ror a\;ror a\;stz _ah";
;    case 12: return "lda _ah\;ror a\;ror a\;ror a\;ror a\;stz _ah";
;    case 13:
;      return "lda #0\;asl _ah\;rol a\;asl _ah\;rol a\;asl _ah\;rol a\;stz _ah";
;    case 14: return "lda #0\;asl _ah\;rol a\;asl _ah\;rol a\;stz _ah";
;    case 15: return "lda #0\;asl _ah\;rol a\;stz _ah";
;    case 16: return "lda #0\;sta _ah";
;    default: gcc_unreachable ();
;    }
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
;	       (eq (match_dup 2) (const_int 2)) (const_int 6)
;	       (eq (match_dup 2) (const_int 3)) (const_int 9)
;	       (eq (match_dup 2) (const_int 4)) (const_int 12)
;	       (eq (match_dup 2) (const_int 5)) (const_int 18)
;	       (eq (match_dup 2) (const_int 6)) (const_int 15)
;	       (eq (match_dup 2) (const_int 7)) (const_int 9)
;	       (eq (match_dup 2) (const_int 8)) (const_int 4)
;	       (eq (match_dup 2) (const_int 9)) (const_int 5)
;	       (eq (match_dup 2) (const_int 10)) (const_int 6)
;	       (eq (match_dup 2) (const_int 11)) (const_int 7)
;	       (eq (match_dup 2) (const_int 12)) (const_int 8)
;	       (eq (match_dup 2) (const_int 13)) (const_int 13)
;	       (eq (match_dup 2) (const_int 14)) (const_int 10)
;	       (eq (match_dup 2) (const_int 15)) (const_int 7)
;	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
;	      (const_int 0)))])
;
;; This can support more addressing modes!
;
;(define_insn "lshrhi3_addhi"
;  [(set (match_operand:HI 0 "zp_reg_operand"				"=r")
;	(plus:HI (lshiftrt:HI (match_operand:HI 1 "accumulator_operand"  "Ah")
;			      (match_operand:HI 2 "shifthi_rt_byteswap"  "Nc"))
;		 (match_operand:HI 3 "zp_reg_operand"			 "r")))
;   (clobber (match_scratch:QI 4 "=Aq"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 5:
;      return "asl _ah\;rol a\;asl _ah\;rol a\;asl _ah\;rol a\;and #7\;"
;	     "pha\;lda %3\;clc\;adc _ah\;sta %0\;pla\;adc %h3\;sta %h0";
;    case 6:
;      return "asl a\;rol _ah\;php\;asl a\;rol _ah\;pla\;asl a\;adc #0\;and #3\;"
;	     "pha\;lda %3\;clc\;adc _ah\;sta %0\;pla\;adc %h3\;sta %h0";
;    default:
;      gcc_unreachable ();
;    }
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 5)) (const_int 24)
;	       (eq (match_dup 2) (const_int 6)) (const_int 26)]
;	      (const_int 0)))])
;
;(define_insn "ashlhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(ashift:HI (match_operand:HI 1 "accumulator_operand"	 "0, 0")
;		   (match_operand:HI 2 "shifthi_amount"		 "Nl,Nx")))
;   (clobber (match_scratch:QI 3 "=X,&jq"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "asl a\;rol _ah";
;    case 2: return "asl a\;rol _ah\;asl a\;rol _ah";
;    case 3: return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah";
;    case 4: return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;"
;		   "asl a\;rol _ah";
;    case 5:
;      return "asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;asl a\;rol _ah\;"
;	     "asl a\;rol _ah";
;    case 6:
;      return "ta%R3\;lda _ah\;ror a\;t%R3a\;ror a\;ror _ah\;ror a\;"
;	     "ror _ah\;ta%R3\;lda _ah\;and #$c0\;st%R3 _ah";
;    case 7: return "lsr _ah\;ror a\;sta _ah\;lda #0\;ror a";
;    case 8: return "sta _ah\;lda #0";
;    case 9: return "asl a\;sta _ah\;lda #0";
;    case 10: return "asl a\;asl a\;sta _ah\;lda #0";
;    case 11: return "asl a\;asl a\;asl a\;sta _ah\;lda #0";
;    case 12: return "asl a\;asl a\;asl a\;asl a\;sta _ah\;lda #0";
;    case 13: return "lsr a\;ror a\;ror a\;ror a\;and #$e0\;sta _ah\;lda #0";
;    case 14: return "lsr a\;ror a\;ror a\;and #$c0\;sta _ah\;lda #0";
;    case 15: return "lsr a\;lda #0\;sta _ah\;ror _ah";
;    case 16: return "lda #0\;sta _ah";
;    }
;  return "";
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
;	       (eq (match_dup 2) (const_int 2)) (const_int 6)
;	       (eq (match_dup 2) (const_int 3)) (const_int 9)
;	       (eq (match_dup 2) (const_int 4)) (const_int 12)
;	       (eq (match_dup 2) (const_int 5)) (const_int 15)
;	       (eq (match_dup 2) (const_int 6)) (const_int 18)
;	       (eq (match_dup 2) (const_int 7)) (const_int 8)
;	       (eq (match_dup 2) (const_int 8)) (const_int 4)
;	       (eq (match_dup 2) (const_int 9)) (const_int 5)
;	       (eq (match_dup 2) (const_int 10)) (const_int 6)
;	       (eq (match_dup 2) (const_int 11)) (const_int 7)
;	       (eq (match_dup 2) (const_int 12)) (const_int 8)
;	       (eq (match_dup 2) (const_int 13)) (const_int 10)
;	       (eq (match_dup 2) (const_int 14)) (const_int 9)
;	       (eq (match_dup 2) (const_int 15)) (const_int 7)
;	       (eq (match_dup 2) (const_int 16)) (const_int 4)]
;	      (const_int 0)))])
;
;(define_insn "ashrhi3"
;  [(set (match_operand:HI 0 "accumulator_operand"		"=Ah,Ah")
;	(ashiftrt:HI (match_operand:HI 1 "accumulator_operand"   "0, 0")
;		     (match_operand:HI 2 "shifthi_amount"	 "Na,Nb")))
;   (clobber (match_scratch:QI 3 "=&jq,X"))]
;  ""
;{
;  switch (INTVAL (operands[2]))
;    {
;    case 1: return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a";
;    case 2:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a";
;    case 3:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a\;cp%R3 #$80\;ror _ah\;ror a";
;    case 4:
;      return "ld%R3 _ah\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;"
;	     "ror a\;cp%R3 #$80\;ror _ah\;ror a\;cp%R3 #$80\;ror _ah\;ror a";
;    case 5:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;rol _ah\;rol a\;"
;	     "and #7\;ld%R3 _ah\;sta _ah\;and #4\;beq :+\;lda _ah\;ora #$f8\;"
;	     "sta _ah\;:\;t%R3a";
;    case 6:
;      return "cmp #$80\;rol _ah\;rol a\;rol _ah\;rol a\;and #3\;ld%R3 _ah\;"
;	     "sta _ah\;and #2\;beq :+\;lda _ah\;ora #$fc\;sta _ah\;:\;t%R3a";
;    case 7:
;      return "cmp #$80\;rol _ah\;lda #0\;sbc #0\;eor #$ff\;ld%R3 _ah\;sta _ah\;"
;	     "t%R3a";
;    case 8:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a";
;    case 9:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a";
;    case 10:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a";
;    case 11:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
;    case 12:
;      return "lda _ah\;ta%R3\;ora #$7f\;bmi :+\;lda #0\;:\;sta _ah\;t%R3a\;"
;	     "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;"
;	     "ror a";
;    case 13:
;      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
;	     "asl _ah\;rol a\;asl _ah\;rol a\;st%R3 _ah";
;    case 14:
;      return "asl _ah\;php\;lda #0\;sbc #0\;eor #$ff\;ta%R3\;plp\;rol a\;"
;	     "asl _ah\;rol a\;st%R3 _ah";
;    case 15:
;    case 16:
;      return "asl _ah\;lda #0\;sbc #0\;eor #$ff\;sta _ah";
;    }
;  return "";
;}
;  [(set (attr "length")
;	(cond [(eq (match_dup 2) (const_int 1)) (const_int 7)
;	       (eq (match_dup 2) (const_int 2)) (const_int 12)
;	       (eq (match_dup 2) (const_int 3)) (const_int 17)
;	       (eq (match_dup 2) (const_int 4)) (const_int 22)
;	       (eq (match_dup 2) (const_int 5)) (const_int 28)
;	       (eq (match_dup 2) (const_int 6)) (const_int 25)
;	       (eq (match_dup 2) (const_int 7)) (const_int 15)
;	       (eq (match_dup 2) (const_int 8)) (const_int 12)
;	       (eq (match_dup 2) (const_int 9)) (const_int 15)
;	       (eq (match_dup 2) (const_int 10)) (const_int 18)
;	       (eq (match_dup 2) (const_int 11)) (const_int 21)
;	       (eq (match_dup 2) (const_int 12)) (const_int 24)
;	       (eq (match_dup 2) (const_int 13)) (const_int 20)
;	       (eq (match_dup 2) (const_int 14)) (const_int 17)
;	       (eq (match_dup 2) (const_int 15)) (const_int 10)
;	       (eq (match_dup 2) (const_int 16)) (const_int 10)]
;	      (const_int 0)))])

(define_expand "cbranchhi4"
  [(parallel
    [(set (pc) (if_then_else
		 (match_operator 0 "m65x_comparison"
	           [(match_operand:HI 1 "register_operand" "")
		    (match_operand:HI 2 "nonmemory_operand" "")])
		 (label_ref (match_operand 3 "" ""))
		 (pc)))
     (clobber (match_scratch:QI 4 ""))])]
  ""
{
  int force_reg_operand;

  switch (GET_CODE (operands[0]))
    {
    case GTU:
    case LEU:
    case GT:
    case LE:
      force_reg_operand = 2;
      break;

    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      force_reg_operand = 1;
      break;

    default:
      gcc_unreachable ();
    }

  if (can_create_pseudo_p () &&
      !register_operand (operands[force_reg_operand], HImode))
    operands[force_reg_operand] = force_reg (HImode,
					     operands[force_reg_operand]);
})

(define_insn_and_split "cbrhi_eq"
  [(set (pc) (if_then_else
	       (eq (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (EQ, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ne"
  [(set (pc) (if_then_else
	       (ne (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (NE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ltu"
  [(set (pc) (if_then_else
	       (ltu (match_operand:HI 0 "zp_reg_operand"        "r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gtu"
  [(set (pc) (if_then_else
	       (gtu (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		    (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LTU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_geu"
  [(set (pc) (if_then_else
	       (geu (match_operand:HI 0 "zp_reg_operand"         "r,r")
		    (match_operand:HI 1 "zp_reg_or_imm_operand"  "r,i"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_leu"
  [(set (pc) (if_then_else
	       (leu (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		    (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	     (label_ref (match_operand 2 "" ""))
	     (pc)))
   (clobber (match_scratch:QI 3 "=hq,hq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GEU, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_lt"
  [(set (pc) (if_then_else
	       (lt (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_gt"
  [(set (pc) (if_then_else
	       (gt (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (LT, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_ge"
  [(set (pc) (if_then_else
	       (ge (match_operand:HI 0 "zp_reg_operand"        "r,r")
		   (match_operand:HI 1 "zp_reg_or_imm_operand" "r,i"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[0], operands[1], operands[2],
			       operands[3]);
  DONE;
})

(define_insn_and_split "cbrhi_le"
  [(set (pc) (if_then_else
	       (le (match_operand:HI 0 "zp_reg_or_imm_operand" "r,i")
		   (match_operand:HI 1 "zp_reg_operand"        "r,r"))
	       (label_ref (match_operand 2 "" ""))
	       (pc)))
   (clobber (match_scratch:QI 3 "=Aq,Aq"))]
  ""
  "#"
  "reload_completed"
  [(pc)]
{
  m65x_emit_himode_comparison (GE, operands[1], operands[0], operands[2],
			       operands[3]);
  DONE;
})

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "zp_reg_operand" "")
	(sign_extend:SI (match_operand:HI 1 "zp_reg_operand" "")))]
  ""
{
  rtx acc = gen_reg_rtx (QImode);
  rtx cmp, new_label = gen_label_rtx ();
  
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 0),
		  simplify_gen_subreg (QImode, operands[1], HImode, 0));
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 1),
		  simplify_gen_subreg (QImode, operands[1], HImode, 1));

  emit_move_insn (acc, simplify_gen_subreg (QImode, operands[1], HImode, 1));
  emit_insn (gen_iorqi3_nz (acc, acc, gen_int_mode (0x7f, QImode)));
  cmp = gen_rtx_LT (VOIDmode, gen_rtx_REG (CC_NZmode, NZ_REGNUM), const0_rtx);
  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
			       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,
				 gen_rtx_LABEL_REF (Pmode, new_label),
				 pc_rtx)));
  emit_move_insn (acc, const0_rtx);
  emit_label (new_label);

  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 2), acc);
  emit_move_insn (simplify_gen_subreg (QImode, operands[0], SImode, 3), acc);
  
  DONE;
})

(define_expand "neghi2"
  [(set (match_operand:HI 0 "reg_or_const_mem_operand" "")
	(neg:HI (match_operand:HI 1 "reg_or_const_mem_operand" "")))]
  ""
{
  rtx zero = force_reg (HImode, const0_rtx);
  emit_insn (gen_subhi3 (operands[0], zero, operands[1]));
  DONE;
})

; QImode operations.

(define_expand "movqi"
  [(parallel [(set (match_operand:QI 0 "nonimmediate_operand" "")
		   (match_operand:QI 1 "general_operand" ""))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{
  if (can_create_pseudo_p ())
    {
      if (MEM_P (operands[0])
	  && (MEM_P (operands[1])
	      || (GET_CODE (operands[1]) == CONST_INT
		  && (INTVAL (operands[1]) != 0
		      || !CONSTANT_ADDRESS_P (XEXP (operands[0], 0))))
	      || (!CONSTANT_ADDRESS_P (XEXP (operands[0], 0))
		  && REG_P (operands[1])
		  && REGNO (operands[1]) != ACC_REGNUM)
	      || !REG_P (operands[1])))
	operands[1] = force_reg (QImode, operands[1]);
      else if (strict_ptr_reg_operand (operands[0], QImode)
	       && immediate_operand (operands[1], QImode)
	       && !(CONST_INT_P (operands[1]) && INTVAL (operands[1]) == 0
		    && TARGET_STZ))
	operands[1] = force_reg (QImode, operands[1]);
      else if ((MEM_P (operands[0])
		|| strict_ptr_reg_operand (operands[0], QImode)
		|| reg_mentioned_p (frame_pointer_rtx, operands[0])
		|| reg_mentioned_p (virtual_stack_vars_rtx, operands[0]))
	       && (MEM_P (operands[1])
		   || strict_ptr_reg_operand (operands[1], QImode)
		   || reg_mentioned_p (frame_pointer_rtx, operands[1])
		   || reg_mentioned_p (virtual_stack_vars_rtx, operands[1])))
	operands[1] = copy_to_mode_reg (QImode, operands[1]);
    }

  if (operands[0] == operands[1])
    DONE;
})

; Note: we need the "r<-m" and "m<-r" constraints because LRA doesn't want
; to use single-register classes (i.e. the accumulator) as a target.  We'll
; have to try our best to clean up post-reload.

(define_insn "movqi_insn"
  [(set (match_operand:QI 0 "nonimmediate_operand"
		"=hq,hq, r,hq,Uc,hq, <,hq, <,Aq,Aq, m,r,Uc,?hq, ?m,?r,?m,rhq")
	(match_operand:QI 1 "general_operand"
		  "i, r,hq,Uc,hq,hq,hq, >,Aq, >, m,Aq,z, z, ?m,?hq,?m,?r,  0"))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "m65x_valid_mov_operands (QImode, operands)"
{
  switch (which_alternative)
    {
    case 0: return "ld%R0 #%1";
    case 1: case 3: return "ld%R0 %1";
    case 2: case 4: return "st%R1 %0";
    
    case 5:
      switch (REGNO (operands[0]))
        {
        case ACC_REGNUM:
	  switch (REGNO (operands[1]))
	    {
	    case ACC_REGNUM: return "";
	    case X_REGNUM: return "txa";
	    case Y_REGNUM: return "tya";
	    default: gcc_unreachable ();
	    }
	  break;
	
	case X_REGNUM:
	  switch (REGNO (operands[1]))
	    {
	    case ACC_REGNUM: return "tax";
	    case X_REGNUM: return "";
	    case Y_REGNUM:
	      if (TARGET_PHX)
	        return "phy\;plx";
	      else
		return "sty _tmp0\;ldx _tmp0";
	    default: gcc_unreachable ();
	    }

	case Y_REGNUM:
	  switch (REGNO (operands[1]))
	    {
	    case ACC_REGNUM: return "tay";
	    case X_REGNUM:
	      if (TARGET_PHX)
	        return "phx\;ply";
	      else
	        return "stx _tmp0\;ldy _tmp0";
	    case Y_REGNUM: return "";
	    default: gcc_unreachable ();
	    }
	
	default:
	  ;
	}
      break;

    case 6: case 8: return "ph%R1";
    case 7: case 9: return "pl%R0";

    case 10:
      if ((REG_P (XEXP (operands[1], 0)) && TARGET_ZPIND)
	  || GET_CODE (XEXP (operands[1], 0)) == PLUS)
        return "lda %1";
      else if (REG_P (XEXP (operands[1], 0)))
        {
	  operands[1] = XEXP (operands[1], 0);
          output_asm_insn ("sty _tmp0\;"
			   "ldy #0\;"
			   "lda (%1),y\;"
			   "ldy _tmp0", operands);
	  return "";
	}
      else
        return "#";

    case 11:
      if ((REG_P (XEXP (operands[0], 0)) && TARGET_ZPIND)
	  || GET_CODE (XEXP (operands[0], 0)) == PLUS)
        return "sta %0";
      else if (REG_P (XEXP (operands[0], 0)))
        {
	  operands[0] = XEXP (operands[0], 0);
          output_asm_insn ("sty _tmp0\;"
			   "ldy #0\;"
			   "sta (%0),y\;"
			   "ldy _tmp0", operands);
	  return "";
	}
      else
        return "#";

    case 12: case 13: return "stz %0";

    case 14:
      if ((REG_P (XEXP (operands[1], 0)) && TARGET_ZPIND)
	  || GET_CODE (XEXP (operands[1], 0)) == PLUS)
        {
	  switch (REGNO (operands[0]))
	    {
	    case ACC_REGNUM:
              output_asm_insn ("lda %1", operands);
	      break;
	    case X_REGNUM:
	      output_asm_insn ("sta _tmp0\;lda %1\;tax\;lda _tmp0", operands);
	      break;
	    case Y_REGNUM:
	      output_asm_insn ("sta _tmp0\;lda %1\;tay\;lda _tmp0", operands);
	      break;
	    default:
	      gcc_unreachable ();
	    }
	  return "";
	}
      else if (REG_P (XEXP (operands[1], 0)))
	{
	  operands[1] = XEXP (operands[1], 0);

	  switch (REGNO (operands[0]))
	    {
	    case ACC_REGNUM:
              output_asm_insn ("sty _tmp0\;"
			       "ldy #0\;"
			       "lda (%1),y\;"
			       "ldy _tmp0", operands);
	      break;
	    case X_REGNUM:
	      output_asm_insn ("sta _tmp0\;"
			       "ldx #0\;"
			       "lda (%1,x)\;"
			       "tax\;"
			       "lda _tmp0", operands);
	      break;
	    case Y_REGNUM:
	      output_asm_insn ("sta _tmp0\;"
			       "ldy #0\;"
			       "lda (%1),y\;"
			       "tay\;"
			       "lda _tmp0", operands);
	      break;
	    default:
	      gcc_unreachable ();
	    }
	  return "";
	}
      else
        return "#";
      break;

    case 15:
      if ((REG_P (XEXP (operands[0], 0)) && TARGET_ZPIND)
	  || GET_CODE (XEXP (operands[0], 0)) == PLUS)
	{
	  switch (REGNO (operands[1]))
	    {
	    case ACC_REGNUM:
	      output_asm_insn ("sta %0", operands);
	      break;
	    case X_REGNUM:
	      output_asm_insn ("sta _tmp0\;"
			       "txa\;"
			       "sta %0\;"
			       "lda _tmp0", operands);
	      break;
	    case Y_REGNUM:
	      /* This is actually storing the Y register, but still using it
	         as an index.  */
	      output_asm_insn ("sta _tmp0\;"
			       "tya\;"
			       "sta %0\;"
			       "lda _tmp0", operands);
	      break;
	    default:
	      gcc_unreachable ();
	    }
	  return "";
	}
      else if (REG_P (XEXP (operands[0], 0)))
	{
	  operands[0] = XEXP (operands[0], 0);

	  switch (REGNO (operands[1]))
	    {
	    case ACC_REGNUM:
	      output_asm_insn ("sty _tmp0\;"
			       "ldy #0\;"
			       "sta (%0),y\;"
			       "ldy _tmp0", operands);
	      break;
	    case X_REGNUM:
	      output_asm_insn ("sty _tmp0\;"
			       "sta _tmp1\;"
			       "ldy #0\;"
			       "txa\;"
			       "sta (%0),y\;"
			       "lda _tmp1\;"
			       "ldy _tmp0", operands);
	      break;
	    case Y_REGNUM:
	      output_asm_insn ("stx _tmp0\;"
			       "sta _tmp1\;"
			       "ldx #0\;"
			       "tya\;"
			       "sta (%0,x)\;"
			       "lda _tmp1\;"
			       "ldx _tmp0", operands);
	      break;
	    default:
	      gcc_unreachable ();
	    }
	  return "";
	}
      else
        return "#";
      break;

    case 16:
      if ((REG_P (XEXP (operands[1], 0)) && TARGET_ZPIND)
	  || GET_CODE (XEXP (operands[1], 0)) == PLUS)
        return "sta _tmp0\;lda %1\;sta %0\;lda _tmp0";
      else if (REG_P (XEXP (operands[1], 0)))
        {
	  operands[1] = XEXP (operands[1], 0);
	  output_asm_insn ("sta _tmp0\;"
			   "sty _tmp1\;"
			   "ldy #0\;"
			   "lda (%1),y\;"
			   "sta %0\;"
			   "ldy _tmp1\;"
			   "lda _tmp0", operands);
	  return "";
	}
      else
        return "#";

    case 17:
      if ((REG_P (XEXP (operands[0], 0)) && TARGET_ZPIND)
	  || GET_CODE (XEXP (operands[0], 0)) == PLUS)
        return "sta _tmp0\;lda %1\;sta %0\;lda _tmp0";
      else if (REG_P (XEXP (operands[0], 0)))
        {
	  operands[0] = XEXP (operands[0], 0);
	  output_asm_insn ("sta _tmp0\;"
			   "sty _tmp1\;"
			   "ldy #0\;"
			   "lda %1\;"
			   "sta (%0),y\;"
			   "ldy _tmp1\;"
			   "lda _tmp0", operands);
	  return "";
	}
      else
        return "#";

    case 18:
      return "";

    default:
      gcc_unreachable ();
    }
  
  gcc_unreachable ();
}
 [(set_attr "length" "2,2,2,3,3,4,1,1,1,1,8,8,2,3,9,13,14,14,0")
  (set_attr "arch" "*,*,*,*,*,*,phx,phx,no_phx,no_phx,*,*,cmos,cmos,*,*,\
		    *,*,*")])

; Fix up indirect ZP-register loads.

(define_peephole2
  [(parallel [(set (match_operand:QI 0 "zp_reg_operand" "")
		   (mem:QI (match_operand:HI 1 "zp_reg_operand" "")))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx xreg = gen_rtx_REG (QImode, X_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  rtx zpreg, seq;
  bool save_needed;

  if ((save_needed = !peep2_regno_dead_p (1, ACC_REGNUM))
      && !m65x_peephole_find_temp_regs (0, 1, &zpreg, NULL))
    FAIL;
  
  start_sequence ();

  if (save_needed)
    emit_move_insn (zpreg, acc);

  if (TARGET_ZPIND)
    {
      emit_move_insn (acc, gen_rtx_MEM (QImode, operands[1]));
      emit_move_insn (operands[0], acc);
    }
  else
    {
      bool x_available = peep2_regno_dead_p (1, X_REGNUM);
      bool y_available = peep2_regno_dead_p (1, Y_REGNUM);

      if (y_available)
	{
	  emit_move_insn (yreg, const0_rtx);
	  emit_insn (gen_loadqi_indy (acc, yreg, operands[1]));
	  emit_move_insn (operands[0], acc);
	}
      else if (x_available)
	{
	  emit_move_insn (xreg, const0_rtx);
	  emit_insn (gen_loadqi_xind (acc, operands[1], xreg));
	  emit_move_insn (operands[0], acc);
	}
      else
        {
	  end_sequence ();
	  FAIL;
	}
    }
  
  if (save_needed)
    emit_move_insn (acc, zpreg);
  
  seq = get_insns ();
  end_sequence ();
  
  emit_insn (seq);

  DONE;
})

; Fix up ZP indirect-indexed loads.

(define_peephole2
  [(parallel [(set (match_operand:QI 0 "zp_reg_operand" "")
		   (mem:QI
		     (plus:HI (zero_extend:HI
				(match_operand:QI 1 "y_reg_operand" ""))
			      (match_operand:HI 2 "zp_reg_operand" ""))))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  rtx zpreg;
  bool save_needed;
  
  if ((save_needed = !peep2_regno_dead_p (1, ACC_REGNUM))
      && !m65x_peephole_find_temp_regs (0, 1, &zpreg, NULL))
    FAIL;
  
  if (save_needed)
    emit_move_insn (zpreg, acc);

  emit_insn (gen_loadqi_indy (acc, yreg, operands[2]));
  emit_move_insn (operands[0], acc);

  if (save_needed)
    emit_move_insn (acc, zpreg);
  
  DONE;
})

; Try to fix up indirect ZP-register stores.

(define_peephole2
  [(parallel [(set (mem:QI (match_operand:HI 0 "zp_reg_operand" ""))
		   (match_operand:QI 1 "zp_reg_operand" ""))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx xreg = gen_rtx_REG (QImode, X_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  rtx zpreg, seq;
  bool save_needed;

  if ((save_needed = !peep2_regno_dead_p (1, ACC_REGNUM))
      && !m65x_peephole_find_temp_regs (0, 1, &zpreg, NULL))
    FAIL;

  start_sequence ();

  if (save_needed)
    emit_move_insn (zpreg, acc);
  
  if (TARGET_ZPIND)
    {
      emit_move_insn (acc, operands[1]);
      emit_move_insn (gen_rtx_MEM (QImode, operands[0]), acc);
    }
  else
    {
      bool x_available = peep2_regno_dead_p (1, X_REGNUM);
      bool y_available = peep2_regno_dead_p (1, Y_REGNUM);

      if (y_available)
	{
	  emit_move_insn (acc, operands[1]);
	  emit_move_insn (yreg, const0_rtx);
	  emit_insn (gen_storeqi_indy (yreg, operands[0], acc));
	}
      else if (x_available)
	{
	  emit_move_insn (acc, operands[1]);
	  emit_move_insn (xreg, const0_rtx);
	  emit_insn (gen_storeqi_xind (operands[0], xreg, acc));
	}
      else
        {
	  end_sequence ();
          FAIL;
	}
    }

  if (save_needed)
    emit_move_insn (acc, zpreg);

  seq = get_insns ();
  end_sequence ();
  
  emit_insn (seq);

  DONE;
})

; Fix up ZP indirect-indexed stores.

(define_peephole2
  [(parallel [(set (mem:QI
		     (plus:HI (zero_extend:HI
				(match_operand:QI 0 "y_reg_operand" ""))
			      (match_operand:HI 1 "zp_reg_operand" "")))
		   (match_operand:QI 2 "zp_reg_operand" ""))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx yreg = gen_rtx_REG (QImode, Y_REGNUM);
  rtx zpreg;
  bool save_needed;
  
  if ((save_needed = !peep2_regno_dead_p (1, ACC_REGNUM))
      && !m65x_peephole_find_temp_regs (0, 1, &zpreg, NULL))
    FAIL;

  if (save_needed)
    emit_move_insn (zpreg, acc);

  emit_move_insn (acc, operands[2]);
  emit_insn (gen_storeqi_indy (yreg, operands[1], acc));

  if (save_needed)
    emit_move_insn (acc, zpreg);

  DONE;
})

(define_expand "loadqi_indy"
  [(parallel [(set (match_operand:QI 0 "accumulator_operand" "")
		   (mem:QI
		     (plus:HI (zero_extend:HI
				(match_operand:QI 1 "y_reg_operand" ""))
			      (match_operand:HI 2 "zp_reg_operand" ""))))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  {})

(define_insn "loadqi_xind"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(mem:QI (unspec:QI [(match_operand:HI 1 "zp_reg_operand" "r")
			    (match_operand:QI 2 "x_reg_operand" "xq")]
			   UNSPEC_XIND)))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "lda (%1,x)"
  [(set_attr "length" "2")])

(define_expand "storeqi_indy"
  [(parallel [(set (mem:QI
		     (plus:HI (zero_extend:HI
		        	(match_operand:QI 0 "y_reg_operand" ""))
			      (match_operand:HI 1 "zp_reg_operand" "")))
		   (match_operand:QI 2 "accumulator_operand" ""))
   (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
  {})

(define_insn "storeqi_xind"
  [(set (mem:QI (unspec:QI [(match_operand:HI 0 "zp_reg_operand" "r")
			    (match_operand:QI 1 "x_reg_operand" "xq")]
			   UNSPEC_XIND))
	(match_operand:QI 2 "accumulator_operand" "Aq"))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "sta (%0,x)"
  [(set_attr "length" "2")])

(define_insn "zp_clob_hardreg_movqi"
  [(set (match_operand:QI 0 "zp_reg_or_const_mem_operand" "=r,Uc, r,Uc")
	(match_operand:QI 1 "zp_reg_or_const_mem_operand"  "r, r,Uc,Uc"))
   (clobber (match_scratch:QI 2 "=hq,hq,hq,hq"))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4,5,5,6")])

; Split ZP-reg load from absolute memory.

(define_split
  [(set (match_operand:QI 0 "zp_reg_operand" "")
	(mem:QI (match_operand:HI 1 "immediate_operand" "")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "reload_completed"
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx par;
  
  emit_insn (m65x_push (QImode, acc));
  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
  XVECEXP (par, 0, 0) = gen_rtx_SET (VOIDmode, acc,
				     gen_rtx_MEM (QImode, operands[1]));
  XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
					 gen_rtx_REG (CC_NZmode, NZ_REGNUM));
  emit_insn (par);
  emit_move_insn (operands[0], acc);
  emit_insn (m65x_pop (QImode, acc));
  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));

  DONE;
})

; Split ZP-reg store to absolute memory.

(define_split
  [(set (mem:QI (match_operand:HI 0 "immediate_operand" ""))
	(match_operand:QI 1 "zp_reg_operand" ""))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "reload_completed"
  [(pc)]
{
  rtx acc = gen_rtx_REG (QImode, ACC_REGNUM);
  rtx par;

  emit_insn (m65x_push (QImode, acc));
  emit_move_insn (acc, operands[1]);
  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));
  XVECEXP (par, 0, 0) = gen_rtx_SET (VOIDmode,
				     gen_rtx_MEM (QImode, operands[0]), acc);
  XVECEXP (par, 0, 1) = gen_rtx_CLOBBER (VOIDmode,
					 gen_rtx_REG (CC_NZmode, NZ_REGNUM));
  emit_insn (par);
  emit_insn (m65x_pop (QImode, acc));
  emit_use (gen_rtx_REG (HImode, HARDSP_REGNUM));

  DONE;
})

(define_insn "load_sym_lo"
  [(set (match_operand:QI 0 "hard_reg_operand" "=hq")
	(subreg:QI (match_operand:HI 1 "sym_const_operand" "i") 0))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "ld%R0 #<(%1)"
  [(set_attr "length" "2")])

(define_insn "load_sym_hi"
  [(set (match_operand:QI 0 "hard_reg_operand" "=hq")
	(subreg:QI (match_operand:HI 1 "sym_const_operand" "i") 1))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "ld%R0 #>(%1)"
  [(set_attr "length" "2")])

(define_expand "pushqi1"
  [(parallel [(set (match_operand:QI 0 "hard_sp_operand"  "")
		   (match_operand:QI 1 "hard_reg_operand" ""))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{})

(define_expand "popqi1"
  [(parallel [(set (match_operand:QI 0 "hard_reg_operand" "")
		   (match_operand:QI 1 "hard_sp_operand"  ""))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{})

(define_insn "pushflags"
  [(set (match_operand:CC 0 "hard_sp_operand" "=<")
	(unspec_volatile:CC [(reg:CC_NZ NZ_REGNUM)
			     (reg:CC_C CARRY_REGNUM)
			     (reg:CC_V OVERFLOW_REGNUM)] UNSPEC_FLAGS))]
  ""
  "php"
  [(set_attr "length" "1")])

(define_insn "popflags"
  [(set (reg:CC_NZ NZ_REGNUM)
	(unspec_volatile:CC_NZ [(match_operand:CC 0 "hard_sp_operand" ">")]
			       UNSPEC_FLAGS_NZ))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec_volatile:CC_C [(match_dup 0)] UNSPEC_FLAGS_C))
   (set (reg:CC_V OVERFLOW_REGNUM)
	(unspec_volatile:CC_V [(match_dup 0)] UNSPEC_FLAGS_V))]
  ""
  "plp"
  [(set_attr "length" "1")])

(define_expand "reload_inoutqi_zp"
  [(parallel [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
		   (match_operand:QI 1 "reload_zpreg_operand" "r"))
	      (clobber (match_operand:QI 2 "hard_reg_operand" "=hq"))])]
  ""
{
})

(define_insn "movqi_loadstore_zp"
  [(set (match_operand:QI 0 "reload_zpreg_operand" "=r")
	(match_operand:QI 1 "reload_zpreg_operand" "r"))
   (clobber (match_scratch:QI 2 "=hq"))]
  ""
  "ld%R2 %1\;st%R2 %0"
  [(set_attr "length" "4")])

; Increment/decrement instructions only affect N/Z, not carry or overflow.
; This is important when they are generated in the middle of multi-byte
; additions or subtractions! I.e. carry must not be marked as clobbered in the
; middle of such operations.

(define_insn "incdecqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"
					    "=Aq,Aq,xq,xq,yq,yq,UX,UX,Uc,Uc")
	(plus:QI (match_operand:QI 1 "nonimmediate_operand"
					     "%0, 0, 0, 0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "const_int_operand"
					      "K, L, K, L, K, L, K, L, K, L")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "INTVAL (operands[2]) == 1 || INTVAL (operands[2]) == -1"
  "@
  inc a
  dec a
  inx
  dex
  iny
  dey
  inc %0
  dec %0
  inc %0
  dec %0"
  [(set_attr "length" "1,1,1,1,1,1,3,3,3,3")
   (set_attr "arch" "cmos,cmos,*,*,*,*,*,*,*,*")])

(define_insn "addqi3"
  [(set (match_operand:QI 0 "hard_reg_operand"
				      "=Aq,Aq,Aq,Aq,Aq,Aq,Aq,xq,yq,Aq,xq,yq")
	(plus:QI (match_operand:QI 1 "hard_reg_operand"
				       "%0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
					"r,Uy,Ur,Uc, K, L, I, K, K, M, L, L")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  clc\;adc %2
  clc\;adc %2
  clc\;adc %2
  clc\;adc %2
  inc a
  dec a
  clc\;adc #%2
  inx
  iny
  sec\;sbc #-%2
  dex
  dey"
  [(set_attr "length" "3,3,3,4,1,1,3,1,1,3,1,1")
   (set_attr "arch" "*,*,cmos,*,cmos,cmos,*,*,*,*,*,*")])

; LRA wants a 3-operand add which does not clobber the condition code
; register(s).  We can only do that by preserving them.
; FIXME: Generally we can probably clean most of these up in some later pass,
; somehow.

(define_insn "addqi3_noclob"
  [(set (match_operand:QI 0 "hard_reg_operand"
					     "=Aq,Aq,Aq,Aq,xq,yq,Aq,xq,yq")
	(plus:QI (match_operand:QI 1 "hard_reg_operand"
					      "%0, 0, 0, 0, 0, 0, 0, 0, 0")
		 (match_operand:QI 2 "general_operand"
					       "r, m, K, I, K, K, M, L, L")))]
  ""
  "@
  php\;clc\;adc %2\;plp
  php\;clc\;adc %2\;plp
  php\;inc a\;plp
  php\;clc\;adc #%2\;plp
  php\;inx\;plp
  php\;iny\;plp
  php\;sec\;sbc #-%2\;plp
  php\;dex\;plp
  php\;dey\;plp"
  [(set_attr "length" "5,5,3,5,3,3,5,3,3")
   (set_attr "arch" "*,*,cmos,*,*,*,*,*,*")])

(define_insn "subqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	    "=Aq,Aq,Aq,Aq")
	(minus:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0, 0")
		  (match_operand:QI 2 "memory_operand"	      "r,Uy,Ur,Uc")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  sec\;sbc %2
  sec\;sbc %2
  sec\;sbc %2
  sec\;sbc %2"
  [(set_attr "length" "3,3,3,4")
   (set_attr "arch" "*,*,cmos,*")])

(define_insn "clc"
  [(set (reg:CC_C CARRY_REGNUM) (const_int 0))]
  ""
  "clc"
  [(set_attr "length" "1")])

(define_insn "sec"
  [(set (reg:CC_C CARRY_REGNUM) (const_int 1))]
  ""
  "sec"
  [(set_attr "length" "1")])

(define_insn "adcqi3_c"
  [(set (match_operand:QI 0 "accumulator_operand"	 "=Aq,Aq,Aq,Aq,Aq,Aq")
	(plus:QI
	  (plus:QI (match_operand:QI 1 "accumulator_operand"
							   "0, 0, 0, 0, 0, 0")
		   (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj"))
	  (ne:QI (reg:CC_C CARRY_REGNUM) (const_int 0))))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		     UNSPEC_ADC_C))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  adc %2
  adc #%2
  adc %2
  adc %2
  adc %2
  adc %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_insn "sbcqi3_c"
  [(set (match_operand:QI 0 "accumulator_operand"        "=Aq,Aq,Aq,Aq,Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand"        "0, 0, 0, 0, 0, 0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj")
		    (eq:QI (reg:CC_C CARRY_REGNUM) (const_int 0)))))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		     UNSPEC_SBC_C))
   (clobber (reg:CC_NZ NZ_REGNUM))
   (clobber (reg:CC_V OVERFLOW_REGNUM))]
  ""
  "@
  sbc %2
  sbc #%2
  sbc %2
  sbc %2
  sbc %2
  sbc %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_insn "sbcqi3_nzv"
  [(set (match_operand:QI 0 "accumulator_operand"        "=Aq,Aq,Aq,Aq,Aq,Aq")
	(minus:QI
	  (match_operand:QI 1 "accumulator_operand"        "0, 0, 0, 0, 0, 0")
	  (minus:QI (match_operand:QI 2 "qimode_src_operand"
							   "r, i,Uy,Ur,Uc,Uj")
		    (ltu:QI (reg:CC_C CARRY_REGNUM) (const_int 0)))))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		      UNSPEC_SBC_NZ))
   (set (reg:CC_V OVERFLOW_REGNUM)
	(unspec:CC_V [(match_dup 1) (match_dup 2) (reg:CC_C CARRY_REGNUM)]
		     UNSPEC_SBC_OVF))
   (clobber (reg:CC_C CARRY_REGNUM))]
  ""
  "@
  sbc %2
  sbc #%2
  sbc %2
  sbc %2
  sbc %2
  sbc %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_expand "negqi2"
  [(set (match_operand:QI 0 "register_operand" "")
	(neg:QI (match_operand:QI 1 "register_operand" "")))]
  ""
{
  rtx tmp = gen_reg_rtx (QImode);
  
  emit_insn (gen_xorqi3 (tmp, operands[1], gen_int_mode (0xff, QImode)));
  emit_insn (gen_sec ());
  emit_insn (gen_adcqi3_c (operands[0], tmp, const0_rtx));
  
  DONE;
})

(define_insn "negate_highbit"
  [(set (match_operand:QI 0 "accumulator_operand" "=Aq")
	(xor:QI (match_operand:QI 1 "accumulator_operand" "0")
		(const_int 128)))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1)] UNSPEC_NEG_HIBIT))]
  ""
  "eor #$80\t; negate top bit"
  [(set_attr "length" "2")])

(define_expand "andqi3"
  [(parallel [(set (match_operand:QI 0 "qimode_ior_dst_operand" "")
		   (and:QI (match_operand:QI 1 "qimode_ior_dst_operand" "")
			   (match_operand:QI 2 "qimode_ior_src_operand" "")))
	      (clobber (reg:CC_NZ NZ_REGNUM))])]
  ""
{
  if (can_create_pseudo_p () && TARGET_TRB_TSB
      && zp_reg_or_const_mem_operand (operands[0], QImode)
      && CONST_INT_P (operands[2]))
    {
      /* This doesn't really work, it gets folded away into an andqi3 again
         (even when that means loading and storing the accumulator).  Maybe
	 setting RTX costs appropriately would help that.  */
      rtx tmp = force_reg (QImode,
			   gen_int_mode (~INTVAL (operands[2]), QImode));
      emit_insn (gen_m65x_trbqi3 (operands[0], tmp, operands[1]));
      DONE;
    }
})

(define_insn "andqi3_insn"
  [(set (match_operand:QI 0 "accumulator_operand"     "=Aq,Aq,Aq,Aq,Aq,Aq")
	(and:QI (match_operand:QI 1 "accumulator_operand"
							"0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"
							"r, i,Uy,Ur,Uc,Uj")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  and %2
  and #%2
  and %2
  and %2
  and %2
  and %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_insn "m65x_trbqi3"
  [(set (match_operand:QI 0 "zp_reg_or_const_mem_operand"         "=r,Uc")
	(and:QI (not:QI (match_operand:QI 1 "accumulator_operand" "Aq,Aq"))
		(match_operand:QI 2 "zp_reg_or_const_mem_operand"  "0, 0")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  "TARGET_TRB_TSB"
  "trb %0"
  [(set_attr "length" "2,3")
   (set_attr "arch" "cmos")])

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "qimode_ior_dst_operand"
						  "=Aq,Aq,Aq,Aq,Aq,Aq, r,Uc")
	(ior:QI (match_operand:QI 1 "qimode_ior_dst_operand"
						    "0, 0, 0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_ior_src_operand"
						    "r, i,Uy,Ur,Uc,Uj,Aq,Aq")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  ora %2
  ora #%2
  ora %2
  ora %2
  ora %2
  ora %2
  tsb %0
  tsb %0"
  [(set_attr "length" "2,2,2,2,3,3,2,3")
   (set_attr "arch" "*,*,*,cmos,*,*,cmos,cmos")])

(define_insn "iorqi3_nz"
  [(set (match_operand:QI 0 "accumulator_operand"	"=Aq,Aq,Aq,Aq,Aq,Aq")
	(ior:QI (match_operand:QI 1 "accumulator_operand" "0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"  "r, i,Uy,Ur,Uc,Uj")))
   (set (reg:CC_NZ NZ_REGNUM)
	(unspec:CC_NZ [(match_dup 1) (match_dup 2)] UNSPEC_IOR_CC))]
  ""
  "@
  ora %2
  ora #%2
  ora %2
  ora %2
  ora %2
  ora %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	"=Aq,Aq,Aq,Aq,Aq,Aq")
	(xor:QI (match_operand:QI 1 "accumulator_operand" "0, 0, 0, 0, 0, 0")
		(match_operand:QI 2 "qimode_src_operand"  "r, i,Uy,Ur,Uc,Uj")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  eor %2
  eor #%2
  eor %2
  eor %2
  eor %2
  eor %2"
  [(set_attr "length" "2,2,2,2,3,3")
   (set_attr "arch" "*,*,*,cmos,*,*")])

(define_expand "ashlqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "")
	(ashift:QI (match_operand:QI 1 "reg_or_const_mem_operand" "")
		   (match_operand:QI 2 "shiftqi_amount" "")))]
  ""
{
  int i;
  rtx tmp;

  if (!CONST_INT_P (operands[2]))
    FAIL;
  
  switch (INTVAL (operands[2]))
    {
    case 1:
      emit_insn (gen_ashlqi3_insn (operands[0], operands[1], operands[2]));
      break;
    
    case 2:
    case 3:
    case 4:
    case 5:
      tmp = gen_reg_rtx (QImode);
      emit_move_insn (tmp, operands[1]);

      for (i = 0; i < INTVAL (operands[2]); i++)
        emit_insn (gen_ashlqi3_insn (tmp, tmp, const1_rtx));

      emit_move_insn (operands[0], tmp);
      break;
    
    case 6:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rorqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, gen_int_mode (0xc0, QImode)));
      break;

    case 7:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rorqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rorqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, gen_int_mode (0x80, QImode)));
      break;

    case 8:
      emit_move_insn (operands[0], const0_rtx);
      break;

    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "ashlqi3_insn"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"         "=Aq,r,Uc,UX")
	(ashift:QI (match_operand:QI 1 "reg_or_const_mem_operand"
								 "0,0, 0, 0")
		   (match_operand:QI 2 "const_one_amount"	 "K,K, K, K")))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (match_dup 2)] UNSPEC_ASL_C))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  asl a
  asl %0
  asl %0
  asl %0"
  [(set_attr "length" "1,2,3,3")])

(define_insn "m65x_rorqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"           "=Aq,r,Uc,UX")
	(unspec:QI [(match_operand:QI 1 "reg_or_const_mem_operand" "0,0, 0, 0")
		    (reg:CC_C CARRY_REGNUM)]
		   UNSPEC_ROR))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (reg:CC_C CARRY_REGNUM)] UNSPEC_ROR))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  ror a
  ror %0
  ror %0
  ror %0"
  [(set_attr "length" "1,2,3,3")])

(define_insn "m65x_rolqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand"           "=Aq,r,Uc,UX")
	(unspec:QI [(match_operand:QI 1 "reg_or_const_mem_operand" "0,0, 0, 0")
		    (reg:CC_C CARRY_REGNUM)]
		   UNSPEC_ROL))
   (set (reg:CC_C CARRY_REGNUM)
	(unspec:CC_C [(match_dup 1) (reg:CC_C CARRY_REGNUM)] UNSPEC_ROL))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  rol a
  rol %0
  rol %0
  rol %0"
  [(set_attr "length" "1,2,3,3")])

(define_expand "lshrqi3"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "")
	(lshiftrt:QI (match_operand:QI 1 "reg_or_const_mem_operand" "")
		     (match_operand:QI 2 "shiftqi_amount" "")))]
  ""
{
  int i;
  rtx tmp;

  if (!CONST_INT_P (operands[2]))
    FAIL;
  
  switch (INTVAL (operands[2]))
    {
    case 1:
      emit_insn (gen_lshrqi3_insn (operands[0], operands[1], operands[2]));
      break;
    
    case 2:
    case 3:
    case 4:
    case 5:
      tmp = gen_reg_rtx (QImode);
      emit_move_insn (tmp, operands[1]);

      for (i = 0; i < INTVAL (operands[2]); i++)
        emit_insn (gen_lshrqi3_insn (tmp, tmp, const1_rtx));

      emit_move_insn (operands[0], tmp);
      break;
    
    case 6:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rolqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, gen_int_mode (0x03, QImode)));
      break;

    case 7:
      tmp = gen_reg_rtx (QImode);
      emit_insn (gen_m65x_rolqi3 (tmp, operands[1]));
      emit_insn (gen_m65x_rolqi3 (tmp, tmp));
      emit_insn (gen_andqi3 (operands[0], tmp, gen_int_mode (0x01, QImode)));
      break;

    case 8:
      emit_move_insn (operands[0], const0_rtx);
      break;

    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "lshrqi3_insn"
  [(set (match_operand:QI 0 "reg_or_const_mem_operand" "=Aq,r,Uc,UX")
	(lshiftrt:QI
	  (match_operand:QI 1 "reg_or_const_mem_operand" "0,0, 0, 0")
	  (match_operand:QI 2 "const_one_amount"	 "K,K, K, K")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "@
  lsr a
  lsr %0
  lsr %0
  lsr %0"
  [(set_attr "length" "1,2,3,3")])

(define_insn "ashrqi3"
  [(set (match_operand:QI 0 "accumulator_operand"	       "=Aq")
	(ashiftrt:QI (match_operand:QI 1 "accumulator_operand"  "0")
		     (match_operand:QI 2 "shiftqi_amount"       "NB")))
   (clobber (reg:CC_C CARRY_REGNUM))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
{
  switch (INTVAL (operands[2]))
    {
    case 1: return "cmp #$80\;ror a";
    case 2: return "cmp #$80\;ror a\;cmp #$80\;ror a";
    case 3: return "cmp #$80\;ror a\;cmp #$80\;ror a\;cmp #$80\;ror a";
    case 4: return "lsr a\;lsr a\;lsr a\;lsr a\;cmp #8\;bcc :+\;ora #$f0\;:";
    case 5: return "lsr a\;lsr a\;lsr a\;lsr a\;lsr a\;cmp #4\;bcc :+\;"
		   "ora #$f8\;:";
    case 6: return "rol a\;rol a\;rol a\;and #3\;cmp #2\;bcc :+\;ora #$fc\;:";
    case 7:
    case 8: return "ora #$7f\;bmi :+\;lda #0\;:";
    default: gcc_unreachable ();
    }
}
  [(set (attr "length")
	(cond [(eq (match_dup 2) (const_int 1)) (const_int 3)
	       (eq (match_dup 2) (const_int 2)) (const_int 6)
	       (eq (match_dup 2) (const_int 3)) (const_int 9)
	       (eq (match_dup 2) (const_int 4)) (const_int 10)
	       (eq (match_dup 2) (const_int 5)) (const_int 11)
	       (eq (match_dup 2) (const_int 6)) (const_int 11)
	       (eq (match_dup 2) (const_int 7)) (const_int 6)
	       (eq (match_dup 2) (const_int 8)) (const_int 6)]
	      (const_int 0)))])

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "accumulator_operand"	  "=Aq")
	(not:QI (match_operand:QI 1 "accumulator_operand"   "0")))
   (clobber (reg:CC_NZ NZ_REGNUM))]
  ""
  "eor #$ff"
  [(set_attr "length" "2")])

; Comparisons.

(define_insn "compareqi"
  [(set (reg:CC_C CARRY_REGNUM)
	(compare:CC_C (match_operand:QI 0 "hard_reg_operand"
						       "hq,hq,hq,Aq,Aq,Aq")
		      (match_operand:QI 1 "compareqi_src_operand"
							"r, i,Uc,Uy,Ur,Uj")))
   (set (reg:CC_NZ NZ_REGNUM)
	(compare:CC_NZ (match_dup 0) (match_dup 1)))]
  ""
  "@
  %C0 %1
  %C0 #%1
  %C0 %1
  %C0 %1
  %C0 %1
  %C0 %1"
  [(set_attr "length" "2,2,3,2,2,3")
   (set_attr "arch" "*,*,*,*,cmos,*")])

; Jumps & calls.

(define_mode_iterator CBRQI [CC_UI CC_V CC_NZ])
(define_mode_attr signedness [(CC_UI "ui") (CC_NZ "nz") (CC_V "v")])
; Warning: symbolic names don't work here! These must be kept in sync with
; register numbers in 6502.h.
(define_mode_attr ccmode_reg [(CC_UI "40") (CC_V "44") (CC_NZ "36")])

(define_insn "condbranchqi_<mode>"
  [(set (pc)
	(if_then_else (match_operator 0 "qimode_<signedness>_comparison"
			[(reg:CBRQI <ccmode_reg>) (const_int 0)])
		      (label_ref (match_operand 1 "" ""))
		      (pc)))]
  ""
{
  m65x_print_branch (<MODE>mode, operands[0], operands[1],
		     get_attr_length (insn) > 2);
  return "";
}
  [(set (attr "length")
	(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -110))
			   (lt (minus (match_dup 1) (pc)) (const_int 110)))
		      (const_int 2)
		      (const_int 5)))])

(define_insn "indirect_jump"
  [(set (pc)
	(match_operand:HI 0 "zp_reg_operand" "r"))]
  ""
  "jmp (%0)"
  [(set_attr "length" "2")])

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp %0"
  [(set_attr "length" "3")])

(define_expand "cbranchqi4"
  [(set (pc) (if_then_else
	       (match_operator 0 "m65x_comparison"
		 [(match_operand:QI 1 "register_operand"	"")
		  (match_operand:QI 2 "nonmemory_operand"	"")])
	       (label_ref (match_operand 3 "" ""))
	       (pc)))]
  ""
{
  switch (GET_CODE (operands[0]))
    {
    case EQ:
    case NE:
    case LTU:
    case GEU:
    case LT:
    case GE:
      m65x_emit_qimode_comparison (GET_CODE (operands[0]), operands[1],
				   operands[2], operands[3]);
      break;

    case LEU:
      m65x_emit_qimode_comparison (GEU, operands[2], operands[1], operands[3]);
      break;

    case GTU:
      m65x_emit_qimode_comparison (LTU, operands[2], operands[1], operands[3]);
      break;

    case LE:
      m65x_emit_qimode_comparison (GE, operands[2], operands[1], operands[3]);
      break;

    case GT:
      m65x_emit_qimode_comparison (LT, operands[2], operands[1], operands[3]);
      break;
    
    default:
      gcc_unreachable ();
    }

  DONE;
})

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")])

(define_expand "call"
  [(parallel [(call (match_operand 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (use (const_int 0))])])

(define_insn "call_sym"
  [(call (mem:QI (match_operand:HI 0 "" ""))
  	 (match_operand 1 "" ""))
   (use (const_int 0))]
  "GET_CODE (operands[0]) == SYMBOL_REF"
  "jsr %0"
  [(set_attr "length" "3")])

(define_insn "call_indirect"
  [(call (mem:QI (match_operand:HI 0 "register_operand" "r"))
	 (match_operand 1 "" ""))
   (use (const_int 0))]
  ""
  "lda #<:+-1\;pha\;lda #>:+-1\;pha\;jmp (%0)\;:"
  [(set_attr "length" "9")])

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
        	   (call (match_operand 1 "memory_operand" "")
  			 (match_operand 2 "general_operand" "")))
	      (use (const_int 0))])])

(define_insn "call_value_sym"
  [(set (match_operand 0 "" "")
        (call (mem:QI (match_operand:HI 1 "" ""))
  	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  "GET_CODE (operands[1]) == SYMBOL_REF"
  "jsr %1"
  [(set_attr "length" "3")])

(define_insn "call_indirect_sym"
  [(set (match_operand 0 "" "")
	(call (mem:QI (match_operand:HI 1 "zp_reg_operand" "r"))
	      (match_operand 2 "general_operand" "")))
   (use (const_int 0))]
  ""
  "lda #<:+-1\;pha\;lda #>:+-1\;pha\;jmp (%0)\;:"
  [(set_attr "length" "9")])

(define_insn "m65x_return"
  [(return)]
  ""
  "rts"
  [(set_attr "length" "1")])

(define_expand "prologue"
  [(pc)]
  ""
{
  m65x_expand_prologue ();
  DONE;
})

(define_expand "epilogue"
  [(pc)]
  ""
{
  m65x_expand_epilogue ();
  DONE;
})
