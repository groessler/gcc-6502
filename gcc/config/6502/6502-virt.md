(define_mode_iterator INT [QI HI SI])

(define_attr "needs_reg" "none,a,a0,a1,y,ay,a0y1,a1y0,ay0,phys,phys0,phys1"
  (const_string "none"))

(define_insn "movqi_virt"
  [(set (match_operand:QI 0 "nonimmediate_operand"
      "=Aq,jq,hq, r,hz,Aq,hq,r,r, <, <,<,<,hz,Uy,hz,Ur,hz, m,hz, m")
        (match_operand:QI 1 "general_operand"
       "jq,Aq, r,hq,hz, >, >,>,>,Aq,hq,r,r,Uy,hz,Ur,hz, m,hz,iS,iS"))]
  "m65x_virt_insns_ok ()"
  "@
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.popqi %0
  v.popqi %0
  v.popqi %0
  v.popqi %0
  v.pushqi %1
  v.pushqi %1
  v.pushqi %1
  v.pushqi %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1
  v.movqi %0, %1"
  [(set_attr "needs_reg"
     "*,*,*,*,phys,*,*,a0,phys0,*,*,a1,phys1,a0,a1,a0y1,a1y0,phys0,phys1,\
      phys0,ay0")
   (set_attr "arch"
     "*,*,*,*,*,no_phx,phx,no_phx,phx,no_phx,phx,no_phx,phx,*,*,*,*,*,*,*,*")]
)

(define_insn "mov<mode>_virt"
  [(set (match_operand:HISI 0 "nonimmediate_operand"
                                              "=hz,hz,Uy,hz,Ur,hz, m,hz, m")
        (match_operand:HISI 1 "general_operand"
                                               "hz,Uy,hz,Ur,hz, m,hz,iS,iS"))]
  "m65x_virt_insns_ok ()"
  "v.mov<mode> %0, %1"
  [(set_attr "needs_reg" "phys,a0y1,a1y0,a0y1,a1y0,phys,phys,phys,ay0")]
)

(define_insn "addhi3_highpart"
  [(set (match_operand:HI 0 "register_operand"                  "=hz")
        (plus:HI (ashift:HI
                   (zero_extend:HI
                     (match_operand:QI 1 "register_operand"      "hz"))
                   (const_int 8))
                 (match_operand:HI 2 "register_operand"          "hz")))]
  "m65x_virt_insns_ok ()"
  "v.indexhi %0, %2, hi(%1)"
  [(set_attr "needs_reg" "a")]
)

;(define_insn_and_split "separated_indexhi_virt"
;  [(set (subreg:QI (match_operand:HI 0 "register_operand" "=hz,hz,hz,hz") 0)
;        (subreg:QI (match_operand:HI 1 "nonmemory_operand" "hz,hz,Si,Si") 0))
;   (set (subreg:QI (match_dup 0) 1)
;        (plus:QI (subreg:QI (match_dup 1) 1)
;                 (match_operand:QI 2 "nonmemory_operand"   "Si,hz,Si,hz")))]
;  ""
;  "v.indexhi %0, %1, %2"
;  "can_create_pseudo_p ()"
;  [(set (match_dup 0) (match_dup 1))]
;{
;  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 0)
;    {
;      rtx plus0 = operands[1];
;      rtx plus0_lo, plus0_hi, tmp_lo, tmp_hi;
;      rtx tmp = gen_reg_rtx (HImode);
;
;      tmp_lo = operand_subword (tmp, 0, 1, HImode);
;      tmp_hi = operand_subword (tmp, 1, 1, HImode);
;
;      /*if (!REG_P (plus0) && !MEM_P (plus0))
;        plus0 = force_reg (Pmode, plus0);*/
;
;      plus0_lo = m65x_gen_subreg (QImode, plus0, HImode, 0);
;      plus0_hi = m65x_gen_subreg (QImode, plus0, HImode, 1);
;      emit_clobber (tmp);
;      emit_move_insn (tmp_lo, plus0_lo);
;      emit_insn (gen_addqi3 (tmp_hi, plus0_hi, operands[2]));
;      emit_move_insn (operands[0], tmp);
;      DONE;
;    }
;})

;(define_insn_and_split "separated_subreg_recombine_virt"
;  [(set (subreg:QI (match_operand:HI 0 "register_operand" "=hz,hz") 0)
;        (subreg:QI (match_operand:HI 1 "nonmemory_operand" "hz,Si") 0))
;   (set (subreg:QI (match_dup 0) 1)
;        (subreg:QI (match_dup 1) 1))]
;  ""
;  "v.movrecomb %0, %1"
;  ""
;  [(set (match_dup 0) (match_dup 1))]
;)

(define_expand "reload_inqi_indy"
  [(set (match_operand:QI 0 "register_operand" "=hz")
        (match_operand:QI 1 "memory_operand"    "UyUc"))
   (clobber (match_operand:QI 2 "register_operand" "=Aq"))]
  ""
{
  fprintf (stderr, "reload_inqi_indy invoked!\n");
  emit_move_insn (operands[2], operands[1]);
  emit_move_insn (operands[0], operands[2]);
  DONE;
})

(define_expand "reload_outqi_indy"
  [(set (match_operand:QI 0 "memory_operand"     "=UyUc")
        (match_operand:QI 1 "register_operand"      "hz"))
   (clobber (match_operand:QI 2 "register_operand" "=Aq"))]
  ""
{
  fprintf (stderr, "reload_outqi_indy invoked!\n");
  emit_move_insn (operands[2], operands[1]);
  emit_move_insn (operands[0], operands[2]);
  DONE;
})

(define_insn "add<mode>3_virt"
  [(set (match_operand:HISI 0 "register_operand"            "=r, r")
        (plus:HISI (match_operand:HISI 1 "register_operand" "%r, 0")
                   (match_operand:HISI 2 "nonmemory_operand" "r,iS")))]
  "m65x_virt_insns_ok ()"
  "v.add<mode> %0, %1, %2"
  [(set_attr "needs_reg" "a,a")]
)

(define_insn "sub<mode>3_virt"
  [(set (match_operand:HISI 0 "nonimmediate_operand"            "=r,m,r,r")
        (minus:HISI (match_operand:HISI 1 "nonimmediate_operand" "r,r,m,r")
                    (match_operand:HISI 2 "nonimmediate_operand" "r,r,r,m")))]
  "m65x_virt_insns_ok ()"
  "v.sub<mode> %0, %1, %2"
  [(set_attr "needs_reg" "a,ay,ay,ay")]
)

; This will hopefully be combined & then gobbled up into an indexed addressing
; mode.
(define_insn "zero_extendqihi2_virt"
  [(set (match_operand:HI 0 "register_operand"                "=r")
        (zero_extend:HI (match_operand:QI 1 "register_operand" "hz")))]
  "m65x_virt_insns_ok ()"
  "v.zexthi %0,%1"
  [(set_attr "needs_reg" "phys")]
)

;(define_insn "add_exthi_virt"
;  [(set (match_operand:HI 0 "zp_reg_operand" "=r")
;        (plus:HI (zero_extend:HI (match_operand:QI 1 "y_reg_operand" "y"))
;                 (match_operand:HI 2 "zp_reg_operand" "r")))]

(define_insn "lshr<mode>3_virt"
  [(set (match_operand:INT 0 "nonimmediate_operand"  "=r,m,m,m, r, r, m, m")
        (lshiftrt:INT (match_operand:INT 1 "general_operand"
                                                      "r,r,m,m, r, m, r, m")
                      (match_operand:INT 2 "general_operand"
                                                      "r,r,r,m,iS,iS,iS,iS")))]
  "m65x_virt_insns_ok ()"
  "v.lsr<mode> %0, %1, %2"
  [(set_attr "needs_reg" "a,ay,ay,ay,a,ay,ay,ay")]
)

(define_insn "ashl<mode>3_virt"
  [(set (match_operand:INT 0 "nonimmediate_operand"  "=r,m,m,m, r, r, m, m")
        (ashift:INT (match_operand:INT 1 "general_operand"
                                                      "r,r,m,m, r, m, r, m")
                    (match_operand:INT 2 "general_operand"
                                                      "r,r,r,m,iS,iS,iS,iS")))]
  "m65x_virt_insns_ok ()"
  "v.asl<mode> %0, %1, %2"
  [(set_attr "needs_reg" "a,ay,ay,ay,a,ay,ay,ay")]
)

(define_insn "ashr<mode>3_virt"
  [(set (match_operand:INT 0 "nonimmediate_operand"  "=r,m,m,m, r, r, m, m")
        (ashiftrt:INT (match_operand:INT 1 "general_operand"
                                                      "r,r,m,m, r, m, r, m")
                      (match_operand:INT 2 "general_operand"
                                                      "r,r,r,m,iS,iS,iS,iS")))]
  "m65x_virt_insns_ok ()"
  "v.asr<mode> %0, %1, %2"
  [(set_attr "needs_reg" "a,ay,ay,ay,a,ay,ay,ay")]
)

(define_insn "andqi3_virt"
  [(set (match_operand:QI 0 "accumulator_operand"         "=Aq,Aq,Aq")
        (and:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
                (match_operand:QI 2 "general_operand"       "r, m,iS")))]
  "m65x_virt_insns_ok ()"
  "v.and %0, %1, %2"
  [(set_attr "needs_reg" "*,y,*")]
)

(define_insn "iorqi3_virt"
  [(set (match_operand:QI 0 "accumulator_operand"         "=Aq,Aq,Aq")
        (ior:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
                (match_operand:QI 2 "general_operand"       "r, m,iS")))]
  "m65x_virt_insns_ok ()"
  "v.or %0, %1, %2"
  [(set_attr "needs_reg" "*,y,*")]
)

(define_insn "xorqi3_virt"
  [(set (match_operand:QI 0 "accumulator_operand"         "=Aq,Aq,Aq")
        (xor:QI (match_operand:QI 1 "accumulator_operand"   "0, 0, 0")
                (match_operand:QI 2 "general_operand"       "r, m,iS")))]
  "m65x_virt_insns_ok ()"
  "v.eor %0, %1, %2"
  [(set_attr "needs_reg" "*,y,*")]
)

(define_insn "compareqi_virt"
  [(set (reg:CC_C CARRY_REGNUM)
        (compare:CC_C (match_operand:QI 0 "hard_reg_operand"
                                                      "hq,hq,hq,Aq,Aq,Aq,Aq")
                      (match_operand:QI 1 "compareqi_src_operand"
                                                       "r,iS,Uc,Uy,Ur,ZX,Uj")))
   (set (reg:CC_NZ NZ_REGNUM)
        (compare:CC_NZ (match_dup 0) (match_dup 1)))]
  "m65x_virt_insns_ok ()"
  "v.cmp %0, %1"
  [(set_attr "needs_reg" "*,*,*,*,*,*,*")]
)
